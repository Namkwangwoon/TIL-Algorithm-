# 인사고과
## 문제 설명
완호네 회사는 연말마다 1년 간의 인사고과에 따라 인센티브를 지급합니다. 각 사원마다 근무 태도 점수와 동료 평가 점수가 기록되어 있는데 만약 어떤 사원이 다른 임의의 사원보다 두 점수가 모두 낮은 경우가 한 번이라도 있다면 그 사원은 인센티브를 받지 못합니다. 그렇지 않은 사원들에 대해서는 두 점수의 합이 높은 순으로 석차를 내어 석차에 따라 인센티브가 차등 지급됩니다. 이때, 두 점수의 합이 동일한 사원들은 동석차이며, 동석차의 수만큼 다음 석차는 건너 뜁니다. 예를 들어 점수의 합이 가장 큰 사원이 2명이라면 1등이 2명이고 2등 없이 다음 석차는 3등부터입니다.

각 사원의 근무 태도 점수와 동료 평가 점수 목록 `scores`이 주어졌을 때, 완호의 석차를 return 하도록 solution 함수를 완성해주세요.

## 제한 사항
- 1 ≤ `scores`의 길이 ≤ 100,000
- `scores`의 각 행은 한 사원의 근무 태도 점수와 동료 평가 점수를 나타내며 [a, b] 형태입니다.
  - `scores[0]`은 완호의 점수입니다.
  - 0 ≤ a, b ≤ 100,000
- 완호가 인센티브를 받지 못하는 경우 -1을 return 합니다.

## 입출력 예
|scores|result|
|-|-|
|[[2,2],[1,4],[3,2],[3,2],[2,1]]|4|

## 입출력 예 설명
5 번째 사원은 3 번째 또는 4 번째 사원보다 근무 태도 점수와 동료 평가 점수가 모두 낮기 때문에 인센티브를 받을 수 없습니다. 2 번째 사원, 3 번째 사원, 4 번째 사원은 두 점수의 합이 5 점으로 최고점이므로 1 등입니다. 1 등이 세 명이므로 2 등과 3 등은 없고 1 번째 사원인 완호는 두 점수의 합이 4 점으로 4 등입니다.

# 내 풀이
```python
def solution(scores):
    wanho = scores[0]
    scores.sort(key=lambda x:x[0]+x[1], reverse=True)
    incentive = []
    
    for i, score in enumerate(scores):
        removal = []
        if sum(score)==sum(wanho):
            return len(incentive)+1
        for check in scores[i+1:]:
            if score[0]>check[0] and score[1]>check[1]:
                if check==wanho: return -1
                scores.remove(check)
        incentive.append(score)
```
정확성  테스트
```
테스트 1 〉	통과 (0.01ms, 10.2MB)
테스트 2 〉	통과 (0.01ms, 10.2MB)
테스트 3 〉	통과 (0.01ms, 10.1MB)
테스트 4 〉	통과 (0.01ms, 10.2MB)
테스트 5 〉	통과 (0.01ms, 10.3MB)
테스트 6 〉	통과 (0.01ms, 10.1MB)
테스트 7 〉	통과 (0.01ms, 10.1MB)
테스트 8 〉	통과 (0.02ms, 10.1MB)
테스트 9 〉	통과 (0.03ms, 10MB)
테스트 10 〉	통과 (0.07ms, 10.2MB)
테스트 11 〉	통과 (0.89ms, 10.3MB)
테스트 12 〉	통과 (0.13ms, 10.1MB)
테스트 13 〉	통과 (2.84ms, 10.4MB)
테스트 14 〉	통과 (2.03ms, 10.3MB)
테스트 15 〉	통과 (24.19ms, 10.8MB)
테스트 16 〉	통과 (21.03ms, 10.9MB)
테스트 17 〉	통과 (52.26ms, 11.6MB)
테스트 18 〉	통과 (3.74ms, 11.9MB)
테스트 19 〉	통과 (355.96ms, 19.6MB)
테스트 20 〉	통과 (481.94ms, 19.3MB)
테스트 21 〉	통과 (10.51ms, 19.1MB)
테스트 22 〉	통과 (1832.33ms, 29.4MB)
테스트 23 〉	통과 (2046.88ms, 29.2MB)
테스트 24 〉	실패 (시간 초과)
테스트 25 〉	실패 (시간 초과)
```
- 효율성은 없었지만, `scores`의 길이가 최대 100,000 이여서, 이중 for문에서는 시간 초과가 날 수 있겠다는 생각을 했다.
- 전략
  - 먼저 `scores`를 등수 대로 정렬한다. (두 점수의 합이 높은 순)
  - `scores`를 돌면서 현재 `score`이후를 봤울 때, 제외되어야 하는 `score`를 바로 제외
    - 여기에서 이중 for문을 사용
    - 뒤에 있는 `score`들은 앞에 나오는 `score`보다 점수의 합이 작거나 같기 때문에, 현재 이후의 `score`들만 보면 된다.
  - 다 제외하고 나면 현재 `score`를 `incentive` 배열에 넣음
  - 이렇게 하면 항상 인센티브를 받는 점수들만 for문에서 나오게 된다.
  - 완호와 같은 점수의 합을 갖는 점수를 마주하면, `incentive`의 길이+1 이 완호의 등수가 됨
- 정확성의 25개중에 마지막 2개만 실패하여, 결국 다른 사람의 풀이를 참고

# 다른 사람의 풀이
```python
def solution(scores):
    wanho = scores[0]
    scores.sort(key=lambda x:(-x[0], x[1]))
    
    answer, max_b = 0, 0
    for score in scores:
        if score[0]>wanho[0] and score[1]>wanho[1]: return -1
        if max_b<=score[1]:
            max_b = score[1]
            if sum(score)>sum(wanho): answer+=1
    
    return answer+1
```
- 전략
  - 가장 중요했던 기법은, `scores`를 `a` 점수의 내림차순, `b` 점수의 오름 차순으로 정렬한 것!!
    - 이렇게 하면 `scores`의 뒤 원소들은 앞 원소들보다 `a` 점수가 항상 작거나 같음
    - 그러다가 만약, 뒤 원소들이 앞 원소들보다 `b` 점수까지 작아져 버리면, 인센티브를 받지 못하게 된다.
      - 같은 `a` 점수 내에서는 뒤 원소의 `b` 점수가 항상 크다는걸 기억해야 한다.
  - 정렬된 `scores`를 보다가, 앞 원소에서 가장 컸던 `b` 점수보다 낮은 `b`점수를 만나게 되면, 그 점수는 `a`와 `b` 점수 모두 작으므로, 인센티브에서 제외된다.
  - 인센티브 대상인 점수들 중, 완호보다 합이 높은 점수를 만나면 완호보다 등수가 높으므로 `answer+=1`
  - 만약 완호보다 두 점수가 높은 score를 만나면, 완호도 인센티브를 받지 못하므로 `return -1`
