# [1차] 셔틀버스
## 문제 설명
카카오에서는 무료 셔틀버스를 운행하기 때문에 판교역에서 편하게 사무실로 올 수 있다. 카카오의 직원은 서로를 '크루'라고 부르는데, 아침마다 많은 크루들이 이 셔틀을 이용하여 출근한다.

이 문제에서는 편의를 위해 셔틀은 다음과 같은 규칙으로 운행한다고 가정하자.

- 셔틀은 `09:00`부터 총 `n`회 `t`분 간격으로 역에 도착하며, 하나의 셔틀에는 최대 `m`명의 승객이 탈 수 있다.
- 셔틀은 도착했을 때 도착한 순간에 대기열에 선 크루까지 포함해서 대기 순서대로 태우고 바로 출발한다. 예를 들어 `09:00`에 도착한 셔틀은 자리가 있다면 `09:00`에 줄을 선 크루도 탈 수 있다.

일찍 나와서 셔틀을 기다리는 것이 귀찮았던 콘은, 일주일간의 집요한 관찰 끝에 어떤 크루가 몇 시에 셔틀 대기열에 도착하는지 알아냈다. 콘이 셔틀을 타고 사무실로 갈 수 있는 도착 시각 중 제일 늦은 시각을 구하여라.

단, 콘은 게으르기 때문에 같은 시각에 도착한 크루 중 대기열에서 제일 뒤에 선다. 또한, 모든 크루는 잠을 자야 하므로 `23:59`에 집에 돌아간다. 따라서 어떤 크루도 다음날 셔틀을 타는 일은 없다.

## 입력 형식
셔틀 운행 횟수 `n`, 셔틀 운행 간격 `t`, 한 셔틀에 탈 수 있는 최대 크루 수 `m`, 크루가 대기열에 도착하는 시각을 모은 배열 `timetable`이 입력으로 주어진다.

- 0 ＜ `n` ≦ 10
- 0 ＜ `t` ≦ 60
- 0 ＜ `m` ≦ 45
`timetable`은 최소 길이 1이고 최대 길이 2000인 배열로, 하루 동안 크루가 대기열에 도착하는 시각이 `HH:MM` 형식으로 이루어져 있다.
크루의 도착 시각 `HH:MM`은 `00:01`에서 `23:59` 사이이다.

## 출력 형식
콘이 무사히 셔틀을 타고 사무실로 갈 수 있는 제일 늦은 도착 시각을 출력한다. 도착 시각은 `HH:MM` 형식이며, `00:00`에서 `23:59` 사이의 값이 될 수 있다.

## 입출력 예제
|n|t|m|timetable|answer|
|-|-|-|-|-|
|1|1|5|["08:00", "08:01", "08:02", "08:03"]|"09:00"|
|2|10|2|["09:10", "09:09", "08:00"]|"09:09"|
|2|1|2|["09:00", "09:00", "09:00", "09:00"]|"08:59"|
|1|1|5|["00:01", "00:01", "00:01", "00:01", "00:01"]|"00:00"|
|1|1|1|["23:59"]|"09:00"|
|10|60|45|["23:59","23:59", "23:59", "23:59", "23:59", "23:59", "23:59", "23:59", "23:59", "23:59", "23:59", "23:59", "23:59", "23:59", "23:59", "23:59"]|"18:00"|

# 내 풀이
```python
from collections import deque

def solution(n, t, m, timetable):
    start_h, start_m = 9, 0
    shuttles = []
    crews = []
    
    for i in range(n):
        H, M = start_h+(t*i)//60, (t*i)%60 
        shuttles.append((H, M))
        
    for time in timetable:
        time_h, time_m = time.split(":")
        crews.append((int(time_h), int(time_m)))
        
    crews = deque(sorted(crews))
    
    crew_h, crew_m, seats = crews[0][0], crews[0][1], 0
    for (shuttle_h, shuttle_m) in shuttles:
        seats = m
        while seats>0 and crews and  (shuttle_h>crews[0][0] or (shuttle_h==crews[0][0] and shuttle_m>=crews[0][1])):
            crew_h, crew_m = crews.popleft()
            seats-=1
    
    if seats==0:
        arrival = min((shuttles[-1]), (crew_h-((60-crew_m)//60), (crew_m+59)%60))
        return ":".join([str(arrival[0]).zfill(2), str(arrival[1]).zfill(2)])
    else: return ":".join([str(shuttles[-1][0]).zfill(2), str(shuttles[-1][1]).zfill(2)])
```
정확성  테스트
```
테스트 1 〉	통과 (0.03ms, 10.6MB)
테스트 2 〉	통과 (0.03ms, 10.5MB)
테스트 3 〉	통과 (0.05ms, 10.5MB)
테스트 4 〉	통과 (0.04ms, 10.5MB)
테스트 5 〉	통과 (0.06ms, 10.5MB)
테스트 6 〉	통과 (0.03ms, 10.4MB)
테스트 7 〉	통과 (0.39ms, 10.5MB)
테스트 8 〉	통과 (0.02ms, 10.5MB)
테스트 9 〉	통과 (0.04ms, 10.2MB)
테스트 10 〉	통과 (0.03ms, 10.5MB)
테스트 11 〉	통과 (0.06ms, 10.4MB)
테스트 12 〉	통과 (0.49ms, 10.5MB)
테스트 13 〉	통과 (0.37ms, 10.5MB)
테스트 14 〉	통과 (0.08ms, 10.3MB)
테스트 15 〉	통과 (0.18ms, 10.5MB)
테스트 16 〉	통과 (0.16ms, 10.4MB)
테스트 17 〉	통과 (0.32ms, 10.4MB)
테스트 18 〉	통과 (0.28ms, 10.4MB)
테스트 19 〉	통과 (0.29ms, 10.3MB)
테스트 20 〉	통과 (0.27ms, 10.3MB)
테스트 21 〉	통과 (1.38ms, 10.7MB)
테스트 22 〉	통과 (0.70ms, 10.3MB)
테스트 23 〉	통과 (0.30ms, 10.4MB)
테스트 24 〉	통과 (1.43ms, 10.5MB)
```
- 전략
  - 그냥 노가다 문제인거 같다.. 50분 정도 걸렸다.
  - 우선은 `timetable` 원소들의 형식을 전부 튜플 형식으로 바꾸고, 셔틀의 간격도 이같은 형식으로 바꿔줬다.
    - 예: `"09:08"` -> `(9, 8)`
  - 이후 `timetable`을 큐인 `crews`로 만들어줌
  - 그리고 for문으로 셔틀을 돌면서, 탈 수 있는 인원들은 `crews`에서 popleft()헤줌
  - 셔틀 for이 끝나고 나면 네 가지 경우의 수가 존재
    1. 남은 크루가 없는 경우(`crews`) and 마지막 셔틀에 자리가 없었던 경우 (`seats==0`)
        - 마지막으로 셔틀을 탔던 크루보다 1분 먼저 타야 집에 갈 수 있음
    2. 남은 크루가 있는 경우(`not crews`) and 마지막 셔틀에 자리가 없었던 경우 (`seats==0`)
        - 마지막으로 셔틀을 탔던 크루보다 1분 먼저 타야 집에 갈 수 있음
    3. 남은 크루가 없는 경우(`crews`) and 마지막 셔틀에 자리가 있었던 경우 (`seats!=0`)
        - 마지막 셔틀 시간에만 맞춰서 타면 된다.
    4. 남은 크루가 있는 경우(`not crews`) and 마지막 셔틀에 자리가 있었던 경우 (`seats!=0`)
        - 남은 크루들은 셔틀을 어차피 못탈 크루들이므로, 마지막 셔틀 시간에 맞춰 타면된다.
