# 산 모양 타일링
## 문제 설명
한 변의 길이가 1인 정삼각형 `2n+1`개를 이어붙여 윗변의 길이가 `n`, 아랫변의 길이가 `n+1`인 사다리꼴을 만들 수 있습니다. 이때 사다리꼴의 윗변과 변을 공유하는 `n`개의 정삼각형 중 일부의 위쪽에 같은 크기의 정삼각형을 붙여 새로운 모양을 만들었습니다. 예를 들어 `n`이 4이고, 1번째, 2번째, 4번째 정삼각형 위에 정삼각형을 붙인 모양은 다음과 같습니다.

![image](https://github.com/user-attachments/assets/468c2b31-3906-4a46-877a-7ea2d93d6615)

이렇게 만든 모양을 **정삼각형 타일** 또는 정삼각형 2개를 이어 붙인 **마름모 타일**로 빈 곳이 없도록 채우려고 합니다. 정삼각형 타일과 마름모 타일은 돌려서 사용할 수 있습니다.

![image](https://github.com/user-attachments/assets/932e9c2f-ee14-444a-b410-1ac9af0df455)

타일을 놓을 때 다른 타일과 겹치거나 모양을 벗어나게 놓을 수는 없습니다. 위의 예시 모양을 채우는 방법 중 일부는 다음과 같습니다.

![image](https://github.com/user-attachments/assets/5b90c5f3-a71d-465b-8f87-a07f4d603418)

사다리꼴의 윗변의 길이를 나타내는 정수 `n`과 사다리꼴 윗변에 붙인 정삼각형을 나타내는 1차원 정수 배열 `tops`가 매개변수로 주어집니다. 이때 문제 설명에 따라 만든 모양을 정삼각형 또는 마름모 타일로 빈 곳이 없도록 채우는 경우의 수를 `10007`로 나눈 나머지를 return 하도록 solution 함수를 완성해 주세요.

## 제한사항
- 1 ≤ `n` ≤ 100,000
- `tops`의 길이 = `n`
  - `tops[i]`는 사다리꼴의 윗변과 변을 공유하는 `i+1`번째 정삼각형의 위쪽에 정삼각형을 붙이는 경우 1, 붙이지 않는 경우 0입니다.
  
## 입출력 예
|n|tops|result|
|-|-|-|
|4|[1, 1, 0, 1]|149|
|2|[0, 1]|11|
|10|[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]|7704|

## 입출력 예 설명
### 입출력 예 #1

문제의 예시와 같습니다. 문제에서 설명한 방법을 포함해 총 149가지 방법이 존재합니다.

따라서 149를 return 해야 합니다.

### 입출력 예 #2

문제 설명에 따라 만든 모양은 다음과 같습니다.

![image](https://github.com/user-attachments/assets/dbef694f-b442-4713-ba5f-7abd7fae1938)

이 모양을 타일로 채우는 방법은 다음과 같이 총 11가지입니다.

![image](https://github.com/user-attachments/assets/0837e678-2918-4127-8a6b-5852c5d0bb93)

따라서 11을 return 해야 합니다.

### 입출력 예 #3

경우의 수는 총 17,711가지입니다. 따라서 17711을 10007로 나눈 나머지인 7704를 return 해야 합니다.

# 내 풀이
```python
def solution(n, tops):
    # ((미포-미포, 미포-포), (포-미포, 포-포))
    add = [((2, 1), (1, 1)), ((3, 1), (2, 1))]
    cases = [add[tops[0]][0]]
    
    for top in tops[1:]:
        pre_case = cases.pop()  # (미포, 포)
        this_case = add[top]    # ((미포-미포, 미포-포), (포-미포, 포-포))
        
        cases.append((pre_case[0]*this_case[0][0] + pre_case[1]*this_case[1][0],
                     pre_case[0]*this_case[0][1] + pre_case[1]*this_case[1][1]))    # (미포, 포)
        
    return sum(cases[0])%10007
```
- 아주 더러운 dp 문제라고 생각했다.
- 전략
  - 타일을 채울 때, 삼각형 모양은 빈칸을 전부 채워줄 수 있으므로, 마름모의 경우의 수만 생각하면 된다.
  - 윗변의 길이가 `i`인 사다리꼴로 윗변의 길이가 `i+1`인 사다리꼴을 계속 만들어 나가보자.
    - 윗변의 길이가 `i`인 사다리꼴은 다음과 같은 두 가지 경우로 끝날 수 있다. 가장 오른쪽 삼각형이 마름모에 (불포함/포함)
      - 불포함된 경우, 아래처럼 4개로 이루어진 큰 삼각형을 채울 수 있음
        ![image](https://github.com/user-attachments/assets/0cb4b0dc-e2f2-489c-b793-52e93e722419)
      - 포함된 경우, 왼쪽 아래를 제외한 3개로 이루어진 큰 삼각형을 채워야 함
        ![image](https://github.com/user-attachments/assets/ffc5a8b2-f80a-45c9-89aa-972f8b7688d4)
      - 하지만 주의할 점이 있다: 이번 사다리꼴 이후에도 `i+2`번째 처리를 해야하므로, 각 경우에 대해 마름모의 가장 오른쪽 아래 (포함/불포함) 여부를 나눠서 넘겨줘야 함
      - 즉, 네 가지 경우의수 고려: (포-미포) (포-포) (미포-미포) (미포-포)
        - 코드에서는 이전 마름모의 맨 오른쪽 포함/미포함으로 하여, (미포-미포) (미포-포) (포-미포) (포-포)
      - 각각은, 윗변에 삼각형이 없으면 2, 1, 1, 1 개, 윗변에 삼각형이 하나 더 있으면 3, 1, 2, 1 개
        - 윗변 삼각형 X
          ![image](https://github.com/user-attachments/assets/e9e0a905-6a45-48c5-872e-d87136083e0a)
        - 윗변 삼각형 O
          ![image](https://github.com/user-attachments/assets/e5ccb740-53ba-4dfd-a9be-27d8040e8c09)
  - 따라서, 맨 처음 마름모의 맨 오름쪽 삼각형의 포함/미포함 여부로 케이스를 나눠서, 계속 곱하고 더해가면 된다.
      
# 다른 사람의 풀이
```python
def solution(n, tops):
    MOD = 10007
    a = [0] * (n + 1)
    b = [0] * (n + 1)
    a[0] = 0
    b[0] = 1

    for k in range(1, n + 1):
        if tops[k - 1]:
            a[k] = (a[k - 1] + b[k - 1]) % MOD
            b[k] = (2 * a[k - 1] + 3 * b[k - 1]) % MOD
        else:
            a[k] = (a[k - 1] + b[k - 1]) % MOD
            b[k] = (a[k - 1] + 2 * b[k - 1]) % MOD

    return (a[n] + b[n]) % MOD
```
- 나와 매우 비슷함, dp로 접근
- 전 사다리꼴에서, 맨 오른쪽을 마름모에 포함한 경우가 `a`, 포함하지 않은 경우가 `b`
- 특이하게, 매 회차마다 10007로 나눠서, 오버플로우가 나지 않도록 함
  - 곱을 한 다음 덧셈 연산을 하는 순서가 반복되기 때문에, 매 회차마다 10007*() + () 로 나눠지므로 결과에 영향을 미치지 않음!!
