# 디스크 컨트롤러
## 문제 설명
하드디스크는 한 번에 하나의 작업만 수행할 수 있습니다. 디스크 컨트롤러를 구현하는 방법은 여러 가지가 있습니다. 가장 일반적인 방법은 요청이 들어온 순서대로 처리하는 것입니다.

예를들어

```
- 0ms 시점에 3ms가 소요되는 A작업 요청
- 1ms 시점에 9ms가 소요되는 B작업 요청
- 2ms 시점에 6ms가 소요되는 C작업 요청
```
와 같은 요청이 들어왔습니다. 이를 그림으로 표현하면 아래와 같습니다.

![image](https://github.com/Namkwangwoon/TIL-Algorithm-/assets/19163372/02aab182-42e2-4019-a6fe-4324e0cfbdcb)

한 번에 하나의 요청만을 수행할 수 있기 때문에 각각의 작업을 요청받은 순서대로 처리하면 다음과 같이 처리 됩니다.

![image](https://github.com/Namkwangwoon/TIL-Algorithm-/assets/19163372/87e4a44c-3b05-4e3b-ac4c-1b30a6afbab7)

```
- A: 3ms 시점에 작업 완료 (요청에서 종료까지 : 3ms)
- B: 1ms부터 대기하다가, 3ms 시점에 작업을 시작해서 12ms 시점에 작업 완료(요청에서 종료까지 : 11ms)
- C: 2ms부터 대기하다가, 12ms 시점에 작업을 시작해서 18ms 시점에 작업 완료(요청에서 종료까지 : 16ms)
```
이 때 각 작업의 요청부터 종료까지 걸린 시간의 평균은 10ms(= (3 + 11 + 16) / 3)가 됩니다.

하지만 A → C → B 순서대로 처리하면

![image](https://github.com/Namkwangwoon/TIL-Algorithm-/assets/19163372/2319ef89-4d16-4675-a6d6-bd9be05761e5)

```
- A: 3ms 시점에 작업 완료(요청에서 종료까지 : 3ms)
- C: 2ms부터 대기하다가, 3ms 시점에 작업을 시작해서 9ms 시점에 작업 완료(요청에서 종료까지 : 7ms)
- B: 1ms부터 대기하다가, 9ms 시점에 작업을 시작해서 18ms 시점에 작업 완료(요청에서 종료까지 : 17ms)
```
이렇게 A → C → B의 순서로 처리하면 각 작업의 요청부터 종료까지 걸린 시간의 평균은 9ms(= (3 + 7 + 17) / 3)가 됩니다.

각 작업에 대해 [작업이 요청되는 시점, 작업의 소요시간]을 담은 2차원 배열 jobs가 매개변수로 주어질 때, 작업의 요청부터 종료까지 걸린 시간의 평균을 가장 줄이는 방법으로 처리하면 평균이 얼마가 되는지 return 하도록 solution 함수를 작성해주세요. (단, 소수점 이하의 수는 버립니다)

## 제한 사항
- jobs의 길이는 1 이상 500 이하입니다.
- jobs의 각 행은 하나의 작업에 대한 [작업이 요청되는 시점, 작업의 소요시간] 입니다.
- 각 작업에 대해 작업이 요청되는 시간은 0 이상 1,000 이하입니다.
- 각 작업에 대해 작업의 소요시간은 1 이상 1,000 이하입니다.
- 하드디스크가 작업을 수행하고 있지 않을 때에는 먼저 요청이 들어온 작업부터 처리합니다.

## 입출력 예
|jobs|return|
|-|-|
|[[0, 3], [1, 9], [2, 6]]|9|

## 입출력 예 설명
문제에 주어진 예와 같습니다.

- 0ms 시점에 3ms 걸리는 작업 요청이 들어옵니다.
- 1ms 시점에 9ms 걸리는 작업 요청이 들어옵니다.
- 2ms 시점에 6ms 걸리는 작업 요청이 들어옵니다.

# 내 풀이
- 효율성 테스트가 없길래, permutation으로 모든 경우의 수에 대한 걸린 시간의 최소를 구하려고 해봤지만, 시간초과
- 가장 관건은, 각 시점의 작업들을 어떤 기준으로 sorting(or 최솟값 추출)을 해야하는지였다.
  - 우선 시작시간이 다른 작업들은, 5번째 제한사항에 의해, 시작시간이 빠른 작업 먼저 수행
  - **시작시간이 같거나 밀려버려 시작시간이 강제로 같아져버린 작업은, 계산해 보면 결국 소요 시간이 적은 작업부터 수행하는게 이득이다!!**
- 위의 sorting 두 번째 기준을 떠올리지 못해서 결국 다른 사람의 풀이를 참고해 다시 풀었다.. 침착하게 변수를 넣고 계산해보는 과정도 필요할듯

```python
import heapq
from collections import deque

def solution(jobs):
    l = len(jobs)
    cur, consumed = 0, 0
    heap = []
    jobs = deque(sorted(jobs))
    
    while jobs or heap:
        while jobs and jobs[0][0]<=cur:
            job = jobs.popleft()
            heapq.heappush(heap, [job[1], job[0]])

        if heap:
            job = heapq.heappop(heap)
            cur = max(job[0]+job[1], cur+job[0])
            consumed += cur-job[1]
        else:
            cur+=1
    
    return consumed // l
```
정확성  테스트
```
테스트 1 〉	통과 (0.66ms, 10.2MB)
테스트 2 〉	통과 (0.61ms, 10.3MB)
테스트 3 〉	통과 (0.52ms, 10.2MB)
테스트 4 〉	통과 (0.50ms, 10.4MB)
테스트 5 〉	통과 (0.63ms, 10.4MB)
테스트 6 〉	통과 (0.04ms, 10.3MB)
테스트 7 〉	통과 (0.47ms, 10.2MB)
테스트 8 〉	통과 (0.36ms, 10.4MB)
테스트 9 〉	통과 (0.24ms, 10.3MB)
테스트 10 〉	통과 (0.71ms, 10.3MB)
테스트 11 〉	통과 (0.02ms, 10.2MB)
테스트 12 〉	통과 (0.02ms, 10.4MB)
테스트 13 〉	통과 (0.02ms, 10.3MB)
테스트 14 〉	통과 (0.02ms, 10.3MB)
테스트 15 〉	통과 (0.01ms, 10.3MB)
테스트 16 〉	통과 (0.01ms, 10.4MB)
테스트 17 〉	통과 (0.01ms, 10.3MB)
테스트 18 〉	통과 (0.01ms, 10.2MB)
테스트 19 〉	통과 (0.01ms, 10.3MB)
테스트 20 〉	통과 (0.01ms, 10.3MB)
```
- 풀이 과정
  - 우선 시작 시간이 이른 순서대로 정렬
  - 현재 시점 cur 에서 실행 가능한 모든 작업들을, 수행 시간이 적은 순서대로 힙에 넣음
  - 힙에서 최소 시간 작업을 꺼내 수행 후, 걸린 시간 측정 및 작업이 끝나면 위에 과정을 다시 수행
  - 모든 작업들이 힙에 들어갔다 나올 때 까지 반복
