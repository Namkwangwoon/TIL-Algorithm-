# 부대복귀
## 문제 설명
강철부대의 각 부대원이 여러 지역에 뿔뿔이 흩어져 특수 임무를 수행 중입니다. 지도에서 강철부대가 위치한 지역을 포함한 각 지역은 유일한 번호로 구분되며, 두 지역 간의 길을 통과하는 데 걸리는 시간은 모두 1로 동일합니다. 임무를 수행한 각 부대원은 지도 정보를 이용하여 최단시간에 부대로 복귀하고자 합니다. 다만 적군의 방해로 인해, 임무의 시작 때와 다르게 되돌아오는 경로가 없어져 복귀가 불가능한 부대원도 있을 수 있습니다.

강철부대가 위치한 지역을 포함한 총지역의 수 `n`, 두 지역을 왕복할 수 있는 길 정보를 담은 2차원 정수 배열 `roads`, 각 부대원이 위치한 서로 다른 지역들을 나타내는 정수 배열 `sources`, 강철부대의 지역 `destination`이 주어졌을 때, 주어진 `sources`의 원소 순서대로 강철부대로 복귀할 수 있는 최단시간을 담은 배열을 return하는 solution 함수를 완성해주세요. 복귀가 불가능한 경우 해당 부대원의 최단시간은 -1입니다.

## 제한사항
- 3 ≤ `n` ≤ 100,000
  - 각 지역은 정수 1부터 `n`까지의 번호로 구분됩니다.
- 2 ≤ `roads`의 길이 ≤ 500,000
  - `roads`의 원소의 길이 = 2
  - `roads`의 원소는 [a, b] 형태로 두 지역 a, b가 서로 왕복할 수 있음을 의미합니다.(1 ≤ a, b ≤ n, a ≠ b)
  - 동일한 정보가 중복해서 주어지지 않습니다.
    - 동일한 [a, b]가 중복해서 주어지지 않습니다.
    - [a, b]가 있다면 [b, a]는 주어지지 않습니다.
- 1 ≤ `sources`의 길이 ≤ 500
  - 1 ≤ `sources[i]` ≤ n
- 1 ≤ `destination` ≤ n

## 입출력 예
|n|roads|sources|destination|result|
|-|-|-|-|-|
|3|[[1, 2], [2, 3]]|[2, 3]|1|[1, 2]|
|5|[[1, 2], [1, 4], [2, 4], [2, 5], [4, 5]]|[1, 3, 5]|5|[2, -1, 0]|

## 입출력 예 설명
### 입출력 예 #1

- 지역 2는 지역 1과 길로 연결되어 있기 때문에, 지역 2에서 지역 1의 최단거리는 1입니다.
- 지역 3에서 지역 1로 이동할 수 있는 최단경로는 지역 3 → 지역 2 → 지역 1 순으로 이동하는 것이기 때문에, 지역 3에서 지역 1의 최단거리는 2입니다.
- 따라서 [1, 2]를 return합니다.

### 입출력 예 #2

- 지역 1에서 지역 5의 최단경로는 지역 1 → 지역 2 → 지역 5 또는 지역 1 → 지역 4 → 지역 5 순으로 이동하는 것이기 때문에, 최단거리는 2입니다.
- 지역 3에서 지역 5로 가는 경로가 없기 때문에, 지역 3에서 지역 5로 가는 최단거리는 -1입니다.
- 지역 5에서 지역 5는 이동할 필요가 없기 때문에, 최단거리는 0입니다.
- 따라서 [2, -1, 0]을 return합니다.

# 내 풀이 1
```python
def solution(n, roads, sources, destination):
    maps = [[100000]*(n+1) for _ in range(n+1)]
    for i in range(n+1): maps[i][i]=0
    
    for road in roads:
        maps[road[0]][road[1]]=1
        maps[road[1]][road[0]]=1
    
    
    for k in range(1, n+1):
        for i in range(1, n+1):
            for j in range(1, n+1):
                maps[i][j] = min(maps[i][j], maps[i][k]+maps[k][j])
    
    answer = []
    for source in sources:
        dist = maps[destination][source] if maps[destination][source]!=100000 else -1
        answer.append(dist)
    
    return answer
```
정확성  테스트
```
테스트 1 〉	통과 (0.13ms, 10.3MB)
테스트 2 〉	통과 (0.02ms, 10.1MB)
테스트 3 〉	통과 (0.06ms, 10.4MB)
테스트 4 〉	통과 (0.02ms, 10.2MB)
테스트 5 〉	통과 (0.14ms, 10.2MB)
테스트 6 〉	실패 (시간 초과)
테스트 7 〉	실패 (시간 초과)
테스트 8 〉	실패 (시간 초과)
테스트 9 〉	실패 (시간 초과)
테스트 10 〉	실패 (시간 초과)
테스트 11 〉	실패 (시간 초과)
테스트 12 〉	실패 (시간 초과)
테스트 13 〉	실패 (시간 초과)
테스트 14 〉	실패 (시간 초과)
테스트 15 〉	실패 (시간 초과)
테스트 16 〉	실패 (시간 초과)
```
- 최소 거리 비용 문제로, 처음에 플로이드-워셜로 접근해봤다.
- 결론은 플로이드-워셜의 단점대로, 시간초과가 나왔다.
  - `n`과 `roads`의 범위가 매우 크기 때문에 당연한 결과였다.
- 전략
  - `roads`를 참고하여 모든 연결된 노드들에 대한 그래프를 딕셔너리로 만듦
  - 각 연결의 비용을 1로 하여 모든 노드 사이의 최소 거리를 구함
  - 구한 모든 노드들의 최소 거리를 참고하여 `sources`의 원소들과 `destination` 사이의 비용을 각각 구함

# 내 풀이 2
```python
from collections import defaultdict, deque

def solution(n, roads, sources, destination):
    maps = defaultdict(list)
    dist = [100000 for _ in range(n+1)]
    dist[destination]=0
    queue = deque([(destination, 0)])
    
    for road in roads:
        maps[road[0]].append(road[1])
        maps[road[1]].append(road[0])
    
    while queue:
        node, d = queue.popleft()
        
        for n in maps[node]:
            if d+1<dist[n]:
                dist[n]=d+1
                queue.append((n, d+1))
    
    answer = []
    for source in sources:
        d = dist[source] if dist[source]!=100000 else -1
        answer.append(d)
        
    return answer
```
정확성  테스트
```
테스트 1 〉	통과 (0.02ms, 10.4MB)
테스트 2 〉	통과 (0.01ms, 10.2MB)
테스트 3 〉	통과 (0.02ms, 10.2MB)
테스트 4 〉	통과 (0.01ms, 10.2MB)
테스트 5 〉	통과 (0.02ms, 10.1MB)
테스트 6 〉	통과 (19.32ms, 16.4MB)
테스트 7 〉	통과 (21.51ms, 17.1MB)
테스트 8 〉	통과 (34.66ms, 21.9MB)
테스트 9 〉	통과 (15.29ms, 13.9MB)
테스트 10 〉	통과 (15.84ms, 14.5MB)
테스트 11 〉	통과 (758.18ms, 117MB)
테스트 12 〉	통과 (714.57ms, 117MB)
테스트 13 〉	통과 (777.49ms, 117MB)
테스트 14 〉	통과 (719.02ms, 117MB)
테스트 15 〉	통과 (674.05ms, 117MB)
테스트 16 〉	통과 (166.00ms, 43.8MB)
```
- 배운지 얼마 안된 다익스트라 알고리즘과 비슷한 방식의 BFS를 사용했더니 통과했다.
- 전략
  - 마찬가지로 모든 연결된 노드들에 대한 그래프를 딕셔너리로 만듦
  - BFS 비슷하게 `destination`으로부터 연결된 노드들을 차례로 살펴보면서 방문하지 않았던 노드만 최소 거리를 업데이트
  - 업데이트 후 그 노드 + 거리값을 큐에 넣음
