# 도둑질
## 문제 설명
도둑이 어느 마을을 털 계획을 하고 있습니다. 이 마을의 모든 집들은 아래 그림과 같이 동그랗게 배치되어 있습니다.

![image](https://github.com/Namkwangwoon/TIL-Algorithm-/assets/19163372/5c22eebf-cbdf-44f7-87a2-6374036a945d)

각 집들은 서로 인접한 집들과 방범장치가 연결되어 있기 때문에 인접한 두 집을 털면 경보가 울립니다.

각 집에 있는 돈이 담긴 배열 money가 주어질 때, 도둑이 훔칠 수 있는 돈의 최댓값을 return 하도록 solution 함수를 작성하세요.

## 제한사항
- 이 마을에 있는 집은 3개 이상 1,000,000개 이하입니다.
- money 배열의 각 원소는 0 이상 1,000 이하인 정수입니다.

## 입출력 예
|money|return|
|-|-|
|[1, 2, 3, 1]|4|

# 다른 사람의 풀이1
- money의 길이가 짝수, 홀수인 경우를 구분하여, 길이가 짝수면, max(홀수 인덱스들의 합, 짝수 인덱스들의 합), 길이가 홀수면, 돌아가면서 max인 값을 구하려 했다.
  - 짝수 경우에서는 실패 (가장 큰 실패 요인..)
    - [1, 10, 1, 1, 10, 1] 인 경우, 인덱스 1, 4를 뽑아 20이 될 수 있다. (항상 지그재그로 뽑아야 하는건 아니다!!)
  - 홀수인 경우는 시간초과
- 결국 다른 사람의 풀이를 참고하여, dp 문제로 money를 돌면서 max값을 계속 업데이트 해야 함
```python
def solution(money):
    l = len(money)
    
    sums1 = [0 for i in range(l-1)]
    sums1[0], sums1[1] = money[0], max(money[0], money[1])
    for i in range(2, l-1):
        sums1[i] = max(money[i]+sums1[i-2], sums1[i-1])

    sums2 = [0 for i in range(l)]
    sums2[0], sums2[1] = 0, money[1]
    for i in range(2, l):
        sums2[i] = max(money[i]+sums2[i-2], sums2[i-1])

    return max(sums1[-1], sums2[-1])
```
- 전략 (다른 사람의 풀이 참고)
  - 가장 거슬리는 것은, money의 첫 인덱스 & 마지막 인덱스 (서로 인접하지만, 리스트 상에서는 안 그래 보인다.)
  - 거슬리는 것에 대해 경우를 나눠, dp 실행
    1. [sums1] 첫 번째 집을 턴 경우 => 마지막 집은 털지 못함
    2. [sums2] 첫 번째 집을 털지 않은 경우 => 마지막 집은 털어도 되고 안털어도 됨
  - 두 경우에 대해서, money의 for문을 돌며 최대로 훔치는 돈을 업데이트
    - i번째 루프에서 최대값은, max(i번째 집 털기+(i-2)까지의 최대, i번째 집 안털기+(i-1)까지의 최대)
