# 징검다리 건너기
## 문제 설명
[본 문제는 정확성과 효율성 테스트 각각 점수가 있는 문제입니다.]

카카오 초등학교의 "니니즈 친구들"이 "라이언" 선생님과 함께 가을 소풍을 가는 중에 징검다리가 있는 개울을 만나서 건너편으로 건너려고 합니다. "라이언" 선생님은 "니니즈 친구들"이 무사히 징검다리를 건널 수 있도록 다음과 같이 규칙을 만들었습니다.

- 징검다리는 일렬로 놓여 있고 각 징검다리의 디딤돌에는 모두 숫자가 적혀 있으며 디딤돌의 숫자는 한 번 밟을 때마다 1씩 줄어듭니다.
- 디딤돌의 숫자가 0이 되면 더 이상 밟을 수 없으며 이때는 그 다음 디딤돌로 한번에 여러 칸을 건너 뛸 수 있습니다.
- 단, 다음으로 밟을 수 있는 디딤돌이 여러 개인 경우 무조건 가장 가까운 디딤돌로만 건너뛸 수 있습니다.

"니니즈 친구들"은 개울의 왼쪽에 있으며, 개울의 오른쪽 건너편에 도착해야 징검다리를 건넌 것으로 인정합니다.

"니니즈 친구들"은 한 번에 한 명씩 징검다리를 건너야 하며, 한 친구가 징검다리를 모두 건넌 후에 그 다음 친구가 건너기 시작합니다.

디딤돌에 적힌 숫자가 순서대로 담긴 배열 stones와 한 번에 건너뛸 수 있는 디딤돌의 최대 칸수 k가 매개변수로 주어질 때, 최대 몇 명까지 징검다리를 건널 수 있는지 return 하도록 solution 함수를 완성해주세요.

## [제한사항]
- 징검다리를 건너야 하는 니니즈 친구들의 수는 무제한 이라고 간주합니다.
- stones 배열의 크기는 1 이상 200,000 이하입니다.
- stones 배열 각 원소들의 값은 1 이상 200,000,000 이하인 자연수입니다.
- k는 1 이상 stones의 길이 이하인 자연수입니다.

## [입출력 예]
|stones|k|result|
|-|-|-|
|[2, 4, 5, 3, 2, 1, 4, 2, 5, 1]|3|3|

## 입출력 예에 대한 설명
### 입출력 예 #1

첫 번째 친구는 다음과 같이 징검다리를 건널 수 있습니다.

![image](https://github.com/Namkwangwoon/TIL-Algorithm-/assets/19163372/0e2342de-3b63-47bf-b483-cfb40c467855)

첫 번째 친구가 징검다리를 건넌 후 디딤돌에 적힌 숫자는 아래 그림과 같습니다.

두 번째 친구도 아래 그림과 같이 징검다리를 건널 수 있습니다.

![image](https://github.com/Namkwangwoon/TIL-Algorithm-/assets/19163372/24091a78-9d2e-463d-a7ab-c2b520c34bbf)

두 번째 친구가 징검다리를 건넌 후 디딤돌에 적힌 숫자는 아래 그림과 같습니다.

세 번째 친구도 아래 그림과 같이 징검다리를 건널 수 있습니다.

![image](https://github.com/Namkwangwoon/TIL-Algorithm-/assets/19163372/3fc40a6e-cd40-4a57-a95c-d2460c158bc5)

세 번째 친구가 징검다리를 건넌 후 디딤돌에 적힌 숫자는 아래 그림과 같습니다.

네 번째 친구가 징검다리를 건너려면, 세 번째 디딤돌에서 일곱 번째 디딤돌로 네 칸을 건너뛰어야 합니다. 하지만 k = 3 이므로 건너뛸 수 없습니다.

![image](https://github.com/Namkwangwoon/TIL-Algorithm-/assets/19163372/3c9aaed6-d745-421b-8839-1ca85e3a9b30)

따라서 최대 3명이 디딤돌을 모두 건널 수 있습니다.

# 내 풀이 1
```python
def solution(stones, k):
    l = len(stones)
    answer = max(stones[0:k])
    
    for i in range(1, l-k+1):
        stone = max(stones[i:i+k])
        answer = min(answer, stone)
    
    return answer
```
정확성  테스트
```
테스트 1 〉	통과 (0.00ms, 10.2MB)
테스트 2 〉	통과 (0.01ms, 10.1MB)
테스트 3 〉	통과 (0.01ms, 10.2MB)
테스트 4 〉	통과 (0.05ms, 10.1MB)
테스트 5 〉	통과 (0.05ms, 10.2MB)
테스트 6 〉	통과 (0.27ms, 10.3MB)
테스트 7 〉	통과 (0.75ms, 10.2MB)
테스트 8 〉	통과 (1.21ms, 10.2MB)
테스트 9 〉	통과 (2.36ms, 10.2MB)
테스트 10 〉	통과 (0.04ms, 10.1MB)
테스트 11 〉	통과 (0.01ms, 10.3MB)
테스트 12 〉	통과 (0.02ms, 10.2MB)
테스트 13 〉	통과 (0.08ms, 10.1MB)
테스트 14 〉	통과 (0.28ms, 10.2MB)
테스트 15 〉	통과 (0.75ms, 10.2MB)
테스트 16 〉	통과 (1.24ms, 10.3MB)
테스트 17 〉	통과 (2.02ms, 10.1MB)
테스트 18 〉	통과 (0.01ms, 10.2MB)
테스트 19 〉	통과 (0.04ms, 10.2MB)
테스트 20 〉	통과 (0.05ms, 10.2MB)
테스트 21 〉	통과 (0.55ms, 10.1MB)
테스트 22 〉	통과 (1.32ms, 10.4MB)
테스트 23 〉	통과 (2.24ms, 10.2MB)
테스트 24 〉	통과 (2.93ms, 10.3MB)
테스트 25 〉	통과 (0.03ms, 10.3MB)
```
효율성  테스트
```
테스트 1 〉	실패 (시간 초과)
테스트 2 〉	실패 (시간 초과)
테스트 3 〉	실패 (시간 초과)
테스트 4 〉	실패 (시간 초과)
테스트 5 〉	실패 (시간 초과)
테스트 6 〉	실패 (시간 초과)
테스트 7 〉	실패 (시간 초과)
테스트 8 〉	실패 (시간 초과)
테스트 9 〉	실패 (시간 초과)
테스트 10 〉	실패 (시간 초과)
테스트 11 〉	실패 (시간 초과)
테스트 12 〉	실패 (시간 초과)
테스트 13 〉	실패 (시간 초과)
테스트 14 〉	실패 (시간 초과)
```
- 나름 효율적으로 풀었다고 생각했지만, 효율성 테스트 실패
- 전략
  - 징검다리를 건너지 못하는 경우는, 디딤돌 숫자들에 1씩 계속 빼다가(>=0), 연속된 0의 갯수가 `k`보다 크거나 같아지는 경우임
  - 따라서, 디딤돌들의 연속된 k개의 숫자들의 `max`값들 중에서, 가장 작은 값이 정답!
- 하지만, `stones`의 길이와 원소들의 범위가 매우 커서 효율성 테스트를 통과하지 못한 것 같다
- 비정상적으로 큰 숫자가 나올 때에는, `"이분 탐색"`을 의심해 봐야 한다는 것을 알면서도 풀이가 떠오르지 않았고, 결국 다른 사람의 풀이를 참고

# 다른 사람의 풀이
```python
def solution(stones, k):
    answer = 0
    s = 1
    # 최대 밟을 수 있는 횟수
    e = max(stones)
    while s <= e:
        # mid명이 건넌 후 다음 사람이 건널 수 있는가?
        mid = (s+e)//2
        # 몇칸씩 건너는지
        l = []
        cnt = 1
        for i in range(len(stones)):
        	# mid명이 건넜으니 
            # 밟을 수 없는 돌 -> 건너뛰기
            if mid >= stones[i]:
                cnt += 1
            # 밟을 수 있는 돌 -> 몇개 건너뛰었는지 저장
            else:
                l.append(cnt)
                cnt = 1
        # 마지막 건너뛰기
        l.append(cnt)
        # 건너뛸 수 있는 최대보다 크면 다 못 건넌다... -> 사람 줄이자
        if max(l) > k:
            e = mid - 1
        # 다 건널 수 있다 -> 사람 늘려보자 + (mid+1)값 저장
        else:
            s = mid + 1
            answer = mid+1
    return answer
```
- 역시나 이분탐색 이었다..

# 내 풀이 2
```python
def solution(stones, k):
    l, r = 1, max(stones)
    l_stones = len(stones)
    answer = 0
    
    while l<=r:
        mid = (l+r)//2
        
        cnt = 0
        for st in stones:
            if st<=mid: cnt+=1
            else: cnt=0
            if cnt>=k:
                answer = mid
                r = mid-1
                break
        else:
            l = mid+1
    
    return answer
```
- 전략
  - 징검다리를 건널 수 있는 최대 인원을 `이분 탐색`으로 찾아야 함!
    - `stones`의 원소들의 값이 1 이상이므로 `l=1`, `stones`의 최대값을 넘는 인원이 건너지는 못하므로 `r=max(stones)`
    - `mid = (l+r)//2` 만큼을 빼며 `stones` 탐색
      - 연속된 0 이하의 수가 `k`번을 넘으면 안됨
