# 스타 수열
## 문제 설명
다음과 같은 것들을 정의합니다.

- 어떤 수열 x의 **부분 수열(Subsequence**)이란, x의 몇몇 원소들을 제거하거나 그러지 않고 남은 원소들이 원래 순서를 유지하여 얻을 수 있는 새로운 수열을 말합니다.
  - 예를 들어, `[1,3]`은 `[1,2,3,4,5]`의 부분수열입니다. 원래 수열에서 2, 4, 5를 제거해서 얻을 수 있기 때문입니다.
- 다음과 같은 조건을 모두 만족하는 수열 x를 **스타 수열**이라고 정의합니다.
  - x의 길이가 2 이상의 짝수입니다. (빈 수열은 허용되지 않습니다.)
  - x의 길이를 2n이라 할 때, 다음과 같은 n개의 집합 `{x[0], x[1]}, {x[2], x[3]}, ..., {x[2n-2], x[2n-1]}` 의 교집합의 원소의 개수가 1 이상입니다.
  - `x[0] != x[1], x[2] != x[3], ..., x[2n-2] != x[2n-1]` 입니다.
  - 예를 들어, `[1,2,1,3,4,1,1,3]`은 스타 수열입니다. `{1,2}, {1,3}, {4,1}, {1,3}` 의 교집합은 `{1}` 이고, 각 집합 내의 숫자들이 서로 다르기 때문입니다.

1차원 정수 배열 a가 매개변수로 주어집니다. a의 모든 부분 수열 중에서 가장 길이가 긴 스타 수열의 길이를 return 하도록 solution 함수를 완성해주세요. 이때, a의 모든 부분 수열 중에서 스타 수열이 없다면, 0을 return 해주세요.

## 제한사항
- a의 길이는 1 이상 500,000 이하입니다.
  - a의 모든 수는 0 이상 (a의 길이) 미만입니다.

## 입출력 예
|a|result|
|-|-|
|[0]|0|
|[5,2,3,3,5,3]|4|
|[0,3,3,0,7,2,0,2,2,0]|8|

## 입출력 예 설명
### 입출력 예 #1

- a의 부분 수열 중에서 주어진 조건을 모두 만족하는 스타 수열이 없으므로, 0을 return 해야 합니다.

### 입출력 예 #2

- `[5,2,5,3]`, `[5,3,3,5]` 는 a의 부분 수열인 동시에 스타 수열입니다. a의 부분 수열 중 이보다 더 긴 스타 수열은 없으므로, 4를 return 해야 합니다.

### 입출력 예 #3

- `[0,3,3,0,7,0,2,0]` 는 a의 부분 수열인 동시에 스타 수열입니다. a의 부분 수열 중 이보다 더 긴 스타 수열은 없으므로, 8을 return 해야 합니다.

# 내 풀이
```python
from collections import defaultdict

def solution(a):
    l = len(a)
    if l==1:
        return 0
    M = 0
    table = [None for _ in range(l)]
    count = defaultdict(int)
    
    for i, aa in enumerate(a):
        
        if (i>0 and a[i-1]!=aa):
            if i>1:
                if a[i-2]==aa:
                    if table[i-2]=='l':
                        count[aa]+=1
                        M = max(count[aa], M)
                        table[i]='l'
                        continue
                else:
                    count[aa]+=1
                    M = max(count[aa], M)
                    table[i]='l'
                    continue
            else:
                count[aa]+=1
                M = max(count[aa], M)
                table[i]='l'
                continue
        
        if (i<l-1 and a[i+1]!=a[i]):
            count[aa]+=1
            M = max(count[aa], M)
            table[i]='r'
    return M*2
```
정확성  테스트
```
테스트 1 〉	통과 (0.01ms, 10.2MB)
테스트 2 〉	통과 (0.01ms, 10.2MB)
테스트 3 〉	통과 (0.01ms, 10.2MB)
테스트 4 〉	통과 (0.02ms, 10.2MB)
테스트 5 〉	통과 (0.02ms, 10.3MB)
테스트 6 〉	통과 (0.02ms, 10MB)
테스트 7 〉	통과 (0.02ms, 10.3MB)
테스트 8 〉	통과 (0.03ms, 10.2MB)
테스트 9 〉	통과 (0.02ms, 10.2MB)
테스트 10 〉	통과 (0.03ms, 10.2MB)
테스트 11 〉	통과 (0.06ms, 10.2MB)
테스트 12 〉	통과 (0.04ms, 10.3MB)
테스트 13 〉	통과 (190.02ms, 25.8MB)
테스트 14 〉	통과 (251.47ms, 36.6MB)
테스트 15 〉	통과 (257.00ms, 36.6MB)
테스트 16 〉	통과 (277.53ms, 36.5MB)
테스트 17 〉	통과 (279.19ms, 42.3MB)
테스트 18 〉	통과 (81.55ms, 19.2MB)
테스트 19 〉	통과 (154.95ms, 28.8MB)
테스트 20 〉	통과 (412.78ms, 51.6MB)
테스트 21 〉	통과 (390.54ms, 51.7MB)
테스트 22 〉	통과 (434.57ms, 51.6MB)
테스트 23 〉	통과 (370.89ms, 45.6MB)
테스트 24 〉	통과 (383.18ms, 50.8MB)
테스트 25 〉	통과 (422.74ms, 51.6MB)
테스트 26 〉	통과 (364.59ms, 48.4MB)
테스트 27 〉	통과 (282.23ms, 42.5MB)
테스트 28 〉	통과 (0.02ms, 10.2MB)
```
- 시간 내에 풀려고 하다보니, 코드가 정리되진 않았다.
- 전략
  - 스타 수열이 최대가 되기 위해서는 `a` 배열의 각 숫자별로 분리해서 살펴볼 필요가 있다.
    - 최적의 경우는 특정 숫자가 2칸을 주기로 나타나는 것
  - 수열의 앞에서부터 살피되, 그 숫자의 앞이나 뒤에 다른 숫자가 하나라도 나와야 스타 수열이 만들어진다.
    - 연속된 같은 숫자가 3개 이상 나오면 2개로 인정
      - ex) `233...334` 에서는 `2334`만 가능
  - 스타 수열을 만들기 위해 쌍을 이루는 숫자의 방향을 나타내는 배열 `table`, 특정 숫자가 쌍을 이룬 갯수 `count`
    - `table`에서 특정 숫자가 왼쪽 숫자와 쌍을 이루면 `l`, 오른쪽 숫자와 쌍을 이루면 `r`
