# 코딩 테스트 공부
## 문제 설명
**[본 문제는 정확성과 효율성 테스트 각각 점수가 있는 문제입니다.]**

당신은 코딩 테스트를 준비하기 위해 공부하려고 합니다. 코딩 테스트 문제를 풀기 위해서는 알고리즘에 대한 지식과 코드를 구현하는 능력이 필요합니다.

알고리즘에 대한 지식은 `알고력`, 코드를 구현하는 능력은 `코딩력`이라고 표현합니다. `알고력`과 `코딩력`은 0 이상의 정수로 표현됩니다.

문제를 풀기 위해서는 문제가 요구하는 일정 이상의 `알고력`과 `코딩력`이 필요합니다.

예를 들어, 당신의 현재 `알고력`이 15, `코딩력`이 10이라고 가정해보겠습니다.

- A라는 문제가 `알고력` 10, `코딩력` 10을 요구한다면 A 문제를 풀 수 있습니다.
- B라는 문제가 `알고력` 10, `코딩력` 20을 요구한다면 `코딩력`이 부족하기 때문에 B 문제를 풀 수 없습니다.
풀 수 없는 문제를 해결하기 위해서는 `알고력`과 `코딩력`을 높여야 합니다. `알고력`과 `코딩력`을 높이기 위한 다음과 같은 방법들이 있습니다.

- `알고력`을 높이기 위해 알고리즘 공부를 합니다. `알고력` 1을 높이기 위해서 1의 시간이 필요합니다.
- `코딩력`을 높이기 위해 코딩 공부를 합니다. `코딩력` 1을 높이기 위해서 1의 시간이 필요합니다.
- 현재 풀 수 있는 문제 중 하나를 풀어 `알고력`과 `코딩력`을 높입니다. 각 문제마다 문제를 풀면 올라가는 알고력과 코딩력이 정해져 있습니다.
- 문제를 하나 푸는 데는 문제가 요구하는 시간이 필요하며 같은 문제를 여러 번 푸는 것이 가능합니다.

당신은 주어진 모든 문제들을 풀 수 있는 `알고력`과 `코딩력`을 얻는 최단시간을 구하려 합니다.

초기의 `알고력`과 `코딩력`을 담은 정수 `alp`와 `cop`, 문제의 정보를 담은 2차원 정수 배열 `problems`가 매개변수로 주어졌을 때, 모든 문제들을 풀 수 있는 `알고력`과 `코딩력`을 얻는 최단시간을 return 하도록 solution 함수를 작성해주세요.

**모든 문제들을 1번 이상씩 풀 필요는 없습니다. `입출력 예 설명`을 참고해주세요.**

## 제한사항
- 초기의 `알고력`을 나타내는 `alp`와 초기의 `코딩력`을 나타내는 `cop`가 입력으로 주어집니다.
  - 0 ≤ `alp`, `cop` ≤ 150
- 1 ≤ `problems`의 길이 ≤ 100
- `problems`의 원소는 [`alp_req`, `cop_req`, `alp_rwd`, `cop_rwd`, `cost`]의 형태로 이루어져 있습니다.
- `alp_req`는 문제를 푸는데 필요한 `알고력`입니다.
  - 0 ≤ `alp_req` ≤ 150
- `cop_req`는 문제를 푸는데 필요한 `코딩력`입니다.
  - 0 ≤ `cop_req` ≤ 150
- `alp_rwd`는 문제를 풀었을 때 증가하는 `알고력`입니다.
  - 0 ≤ `alp_rwd` ≤ 30
- `cop_rwd`는 문제를 풀었을 때 증가하는 `코딩력`입니다.
  - 0 ≤ `cop_rwd` ≤ 30
- `cost`는 문제를 푸는데 드는 시간입니다.
  - 1 ≤ `cost` ≤ 100
  
### 정확성 테스트 케이스 제한사항

- 0 ≤ `alp`, `cop` ≤ 20
- 1 ≤ `problems`의 길이 ≤ 6
  - 0 ≤ `alp_req`, `cop_req` ≤ 20
  - 0 ≤ `alp_rwd`, `cop_rwd` ≤ 5
  - 1 ≤ `cost` ≤ 10

### 효율성 테스트 케이스 제한사항

- 주어진 조건 외 추가 제한사항 없습니다.

## 입출력 예
|alp|cop|problems|result|
|-|-|-|-|
|10|10|[[10,15,2,1,2],[20,20,3,3,4]]|15|
|0|0|[[0,0,2,1,2],[4,5,3,1,2],[4,11,4,0,2],[10,4,0,4,2]]|13|

## 입출력 예 설명
### 입출력 예 #1

1. `코딩력` 5를 늘립니다. `알고력` 10, `코딩력` 15가 되며 시간이 5만큼 소요됩니다.
2. 1번 문제를 5번 풉니다. `알고력` 20, `코딩력` 20이 되며 시간이 10만큼 소요됩니다. 15의 시간을 소요하여 모든 문제를 풀 수 있는 `알고력`과 `코딩력`을 가질 수 있습니다.

### 입출력 예 #2

1. 1번 문제를 2번 풉니다. `알고력` 4, `코딩력` 2가 되며 시간이 4만큼 소요됩니다.
2. `코딩력` 3을 늘립니다. `알고력` 4, `코딩력` 5가 되며 시간이 3만큼 소요됩니다.
3. 2번 문제를 2번 풉니다. `알고력` 10, `코딩력` 7이 되며 시간이 4만큼 소요됩니다.
4. 4번 문제를 1번 풉니다. `알고력` 10, `코딩력` 11이 되며 시간이 2만큼 소요됩니다. 13의 시간을 소요하여 모든 문제를 풀 수 있는 `알고력`과 `코딩력`을 가질 수 있습니다.

## 제한시간 안내

- 정확성 테스트 : 10초
- 효율성 테스트 : 언어별로 작성된 정답 코드의 실행 시간의 적정 배수

# 다른 사람의 풀이
- 풀이법이 도저히 생각이 나지 않을 만큼 어려운 문제였고, 결국 다른 사람의 풀이를 참고했다.
```python
def solution(alp, cop, problems):
    max_alp, max_cop = 0, 0
    for problem in problems:
        max_alp = max(max_alp, problem[0])
        max_cop = max(max_cop, problem[1])
    
    dp = [[float('inf') for _ in range(max_cop+1)] for _ in range(max_alp+1)]
    
    alp = min(alp, max_alp)
    cop = min(cop, max_cop)
    
    dp[alp][cop]=0
    
    for i in range(alp, max_alp+1):
        for j in range(cop, max_cop+1):
            if i+1<=max_alp:
                dp[i+1][j] = min(dp[i+1][j], dp[i][j]+1)
            if j+1<=max_cop:
                dp[i][j+1] = min(dp[i][j+1], dp[i][j]+1)
            
            for problem in problems:
                if i>=problem[0] and j>=problem[1]:
                    cur_alp = min(max_alp, i+problem[2])
                    cur_cop = min(max_cop, j+problem[3])
                    dp[cur_alp][cur_cop] = min(dp[cur_alp][cur_cop], dp[i][j]+problem[-1])
    
    return dp[max_alp][max_cop]
```
- 전략
  - 결국 이 문제의 목표는, 최소의 시간으로 `코딩력`과 `알고력`이 모든 문제를 풀 수 있을 정도가 되는 것
  - 이 풀이에서는 DP를 통해 접근하여, dp에는 해당 `코딩력` 및 `알고력`의 최소 시간을 저장
  - 초기의 `코딩력`과 `알고력` 부터 목표로 하는 `코딩력` 및 `알고력`까지의 최소 시간을 계속해서 업데이트 해줌
    - 초기의 `코딩력`과 `알고력`이 목표로 하는 값보다 크면, 목표로 하는 값부터 시작해서 업데이트 하면 됨 (즉, 목표로 하는 값 이상이 걸리는 시간은 볼 필요가 없음)
      - (현재의 `코딩력`과 `알고력`에서 각각을 1 올리기 위한 공부를 했을 때 + 현재 풀 수 있는 문제들을 풀었을 때) 의 결과를 업데이트
      - 목표로 하는 `코딩력`과 `알고력`을 넘어갔을 때는, 그냥 목표로 하는 값에다가 업데이트
