# 미로 탈출 명령어
## 문제 설명
`n` x `m` 격자 미로가 주어집니다. 당신은 미로의 (x, y)에서 출발해 (r, c)로 이동해서 탈출해야 합니다.

단, 미로를 탈출하는 조건이 세 가지 있습니다.

1. 격자의 바깥으로는 나갈 수 없습니다.
2. (x, y)에서 (r, c)까지 이동하는 거리가 총 `k`여야 합니다. **이때, (x, y)와 (r, c)격자를 포함해, 같은 격자를 두 번 이상 방문해도 됩니다.**
3. 미로에서 탈출한 경로를 문자열로 나타냈을 때, 문자열이 사전 순으로 가장 빠른 경로로 탈출해야 합니다.

이동 경로는 다음과 같이 문자열로 바꿀 수 있습니다.

- l: 왼쪽으로 한 칸 이동
- r: 오른쪽으로 한 칸 이동
- u: 위쪽으로 한 칸 이동
- d: 아래쪽으로 한 칸 이동

예를 들어, 왼쪽으로 한 칸, 위로 한 칸, 왼쪽으로 한 칸 움직였다면, 문자열 `"lul"`로 나타낼 수 있습니다.

미로에서는 인접한 상, 하, 좌, 우 격자로 한 칸씩 이동할 수 있습니다.

예를 들어 다음과 같이 3 x 4 격자가 있다고 가정해 보겠습니다.
```
....
..S.
E...
```
미로의 좌측 상단은 (1, 1)이고 우측 하단은 (3, 4)입니다. `.`은 빈 공간, `S`는 출발 지점, `E`는 탈출 지점입니다.

탈출까지 이동해야 하는 거리 `k`가 5라면 다음과 같은 경로로 탈출할 수 있습니다.

1. lldud
2. ulldd
3. rdlll
4. dllrl
5. dllud
6. ...

이때 dllrl보다 사전 순으로 빠른 경로로 탈출할 수는 없습니다.

격자의 크기를 뜻하는 정수 `n`, `m`, 출발 위치를 뜻하는 정수 `x`, `y`, 탈출 지점을 뜻하는 정수 `r`, `c`, 탈출까지 이동해야 하는 거리를 뜻하는 정수 `k`가 매개변수로 주어집니다. 이때, 미로를 탈출하기 위한 경로를 return 하도록 solution 함수를 완성해주세요. **단, 위 조건대로 미로를 탈출할 수 없는 경우 `"impossible"`을 return 해야 합니다.**

## 제한사항
- 2 ≤ `n` (= 미로의 세로 길이) ≤ 50
- 2 ≤ `m` (= 미로의 가로 길이) ≤ 50
- 1 ≤ `x` ≤ `n`
- 1 ≤ `y` ≤ `m`
- 1 ≤ `r` ≤ `n`
- 1 ≤ `c` ≤ `m`
- (`x`, `y`) ≠ (`r`, `c`)
- 1 ≤ `k` ≤ 2,500

## 입출력 예
|n|m|x|y|r|c|k|result|
|-|-|-|-|-|-|-|-|
|3|4|2|3|3|1|5|"dllrl"|
|2|2|1|1|2|2|2|"dr"|
|3|3|1|2|3|3|4|"impossible"|

## 입출력 예 설명
### 입출력 예 #1

문제 예시와 동일합니다.

### 입출력 예 #2

미로의 크기는 2 x 2입니다. 출발 지점은 (1, 1)이고, 탈출 지점은 (2, 2)입니다.

빈 공간은 `.`, 출발 지점을 `S`, 탈출 지점을 `E`로 나타내면 다음과 같습니다.
```
S.
.E
```
미로의 좌측 상단은 (1, 1)이고 우측 하단은 (2, 2)입니다.

탈출까지 이동해야 하는 거리 `k`가 2이므로 다음과 같은 경로로 탈출할 수 있습니다.

1. rd
2. dr

`"dr"`이 사전 순으로 가장 빠른 경로입니다. 따라서 `"dr"`을 return 해야 합니다.

## 입출력 예 #3

미로의 크기는 3 x 3입니다. 출발 지점은 (1, 2)이고, 탈출 지점은 (3, 3)입니다.

빈 공간은 `.`, 출발 지점을 `S`, 탈출 지점을 `E`로 나타내면 다음과 같습니다.
```
.S.
...
..E
```
미로의 좌측 상단은 (1, 1)이고 우측 하단은 (3, 3)입니다.

탈출까지 이동해야 하는 거리 `k`가 4입니다. 이때, 이동 거리가 4이면서, `S`에서 `E`까지 이동할 수 있는 경로는 존재하지 않습니다.

따라서 `"impossible"`을 return 해야 합니다.

# 내 풀이1
```python
import sys
sys.setrecursionlimit(1000000000)

def solution(n, m, x, y, r, c, k):
    answer = []
    direc = [(1,0), (0,-1), (0,1), (-1,0)]
    st = ['d', 'l', 'r', 'u']
    
    if (abs(x-r)+abs(y-c))%2!=k%2 or abs(x-r)+abs(y-c)>k: return 'impossible'
    
    def dfs(X, Y, count, string):
        for i, d in enumerate(direc):
            if 1<=X+d[0]<=n and 1<=Y+d[1]<=m:
                if count+1==k and X+d[0]==r and Y+d[1]==c:
                    answer.append(string+st[i])
                    return
                if abs(X+d[0]-r)+abs(Y+d[1]-c)>k-count-1:
                    continue
                    
                dfs(X+d[0], Y+d[1], count+1, string+st[i])
                
                if answer: return
        
    dfs(x, y, 0, "")
    
    return answer[0]
```
정확성  테스트
```
테스트 1 〉	통과 (0.13ms, 10.3MB)
테스트 2 〉	통과 (0.26ms, 10.4MB)
테스트 3 〉	통과 (0.01ms, 10.1MB)
테스트 4 〉	통과 (0.02ms, 10.5MB)
테스트 5 〉	통과 (0.02ms, 10.3MB)
테스트 6 〉	통과 (0.03ms, 10.4MB)
테스트 7 〉	통과 (0.02ms, 10.2MB)
테스트 8 〉	통과 (0.03ms, 10.3MB)
테스트 9 〉	통과 (6.87ms, 16.3MB)
테스트 10 〉	통과 (8.11ms, 16.3MB)
테스트 11 〉	통과 (9.35ms, 16.3MB)
테스트 12 〉	통과 (10.81ms, 16.3MB)
테스트 13 〉	통과 (9.35ms, 16.5MB)
테스트 14 〉	통과 (7.55ms, 16.3MB)
테스트 15 〉	통과 (10.57ms, 16.3MB)
테스트 16 〉	통과 (10.40ms, 16.4MB)
테스트 17 〉	통과 (7.26ms, 16.3MB)
테스트 18 〉	통과 (7.45ms, 16.4MB)
테스트 19 〉	통과 (6.80ms, 16.3MB)
테스트 20 〉	통과 (10.71ms, 16.4MB)
테스트 21 〉	통과 (7.22ms, 16.3MB)
테스트 22 〉	통과 (10.56ms, 16.2MB)
테스트 23 〉	통과 (6.85ms, 16.3MB)
테스트 24 〉	통과 (6.48ms, 16.3MB)
테스트 25 〉	통과 (8.47ms, 16.3MB)
테스트 26 〉	통과 (7.63ms, 16.3MB)
테스트 27 〉	통과 (6.53ms, 16.2MB)
테스트 28 〉	통과 (9.99ms, 16.4MB)
테스트 29 〉	통과 (10.45ms, 16.3MB)
테스트 30 〉	통과 (9.28ms, 16.2MB)
테스트 31 〉	통과 (0.00ms, 10.3MB)
```
- 테스트 케이스 3번에서만 계속 런타임 에러가 났었는데, 다른 사람의 풀이를 참고하고 나니 `k`가 `(x, y)`와 `(r, c)` 사이의 거리보다 작은 경우를 빼먹었다..
  - 문제를 꼼꼼이 읽으면서 당연하다고 생각한 조건을 간과하면 안된다!
- 전략
  - 우선은 처음부터 불가능한 경우를 제외해준다.
    - 이동 가능한 거리와 목표 지점까지의 짝-홀이 안맞는 경우
    - **이동 가능한 거리가 목표 지점까지의 최단 거리보다 작은 경우** (내가 빼먹은 조건)
  - dfs로 탐색한다
  - 현재 지점으로부터 이동 가능 거리가 현재 지점으로부터 목표 지점까지의 최단 거리보다 작은 경우 탐색 종료
