# 사칙연산
## 문제 설명
사칙연산에서 더하기(+)는 결합법칙이 성립하지만, 빼기(-)는 결합법칙이 성립하지 않습니다.
예를 들어 식 1 - 5 - 3은 연산 순서에 따라 다음과 같이 다른 결과를 가집니다.

- ((1 - 5) - 3) = -7
- (1 - (5 - 3)) = -1

위 예시와 같이 뺄셈은 연산 순서에 따라 그 결과가 바뀔 수 있습니다.
또 다른 예로 식 1 - 3 + 5 - 8은 연산 순서에 따라 다음과 같이 5가지 결과가 나옵니다.

- (((1 - 3) + 5) - 8) = -5
- ((1 - (3 + 5)) - 8) = -15
- (1 - ((3 + 5) - 8)) = 1
- (1 - (3 + (5 - 8))) = 1
- ((1 - 3) + (5 - 8)) = -5

위와 같이 서로 다른 연산 순서의 계산 결과는 `[-15, -5, -5, 1, 1]`이 되며, 이중 최댓값은 1입니다.
문자열 형태의 숫자와, 더하기 기호("+"), 뺄셈 기호("-")가 들어있는 배열 arr가 매개변수로 주어질 때, 서로 다른 연산순서의 계산 결과 중 최댓값을 return 하도록 solution 함수를 완성해 주세요.

## 제한 사항
- arr는 두 연산자 "+", "-" 와 숫자가 들어있는 배열이며, 길이는 3 이상 201 이하 입니다.
  - arr의 길이는 항상 홀수입니다.
  - arr에 들어있는 숫자의 개수는 2개 이상 101개 이하이며, 연산자의 개수는 (숫자의 개수) -1 입니다.
  - 숫자는 1 이상 1,000 이하의 자연수가 문자열 형태로 들어있습니다.. (ex : "456")
- 배열의 첫 번째 원소와 마지막 원소는 반드시 숫자이며, 숫자와 연산자가 항상 번갈아가며 들어있습니다.

## 입출력 예
|arr|result|
|-|-|
|["1", "-", "3", "+", "5", "-", "8"]|1|
|["5", "-", "3", "+", "1", "+", "2", "-", "4"]|3|

## 입출력 예시
### 입출력 예 #1
위의 예시와 같이 (1-(3+(5-8))) = 1 입니다.

### 입출력 예 #2
(5-(3+((1+2)-4))) = 3 입니다.

# 다른 사람의 풀이1
- 일단 역대급으로 어려운 문제였다.. 다른 사람의 풀이를 이해하고, 다시 오류 없이 코딩하는데만 해도 굉장히 오래 걸렸다.
- 그래도, 혼자 절반 정도의 점수까지는 왔었다. (몇 가지 개념을 놓쳤다.)
  - 우선 (+)가 연속으로 붙은 수들끼리는 부호가 항상 같아야 최대 혹은 최소의 의미가 있다는 개념에서 출발
  - 가장 관건은, (-)가 나오면 어느 범위까지 (-)의 영향을 줘야할까 였다.
  - 그래서 유사 dp 처럼,
      {(연속으로 (+) 붙은 수) - (최소)}
      = {(연속으로 (+) 붙은 수) - (최소 - (최대))}
      = {(연속으로 (+) 붙은 수) - (최소 - (최대 - (최소)))}
      ...
      = {(연속으로 (+) 붙은 수) - (최소 - (최대 - (최소 ... - ())))}
    를 고려할려고 했지만, **항상 -(최대) < +(최소)는 아니라는 사실을 놓쳤다. (둘 다 부호가 마이너스면, -(최대) > +(최소))**
  - 그리고 **"- a + b - c"가 (-a+b-c), (-a-b-c), (-a-b+c) 이렇게 세 가지가 될 수 있다는 사실을 놓쳤다.**
  - "-a+b-c = -(a-b+c)"를 시작으로 ()안의 최대 혹은 최소를 구해야 했는데, (-)를 제외한 영역의 최대 최소를 구하려 a+b-c에서 시작해버렸다,,
```python
def solution(arr):
  min_val, max_val = 0, 0
  nums = []
  for a in arr[::-1]:
      if a=="-":
          tmp_min, tmp_max = min_val, max_val
          if len(nums)==1:
              min_val = min(-nums[-1]+tmp_min, -nums[-1]-tmp_max)
              max_val = max(-nums[-1]-tmp_min, -nums[-1]+tmp_max)
          else:
              sums = sum(nums[:-1])
              min_val = min(-nums[-1]-sums+tmp_min, -nums[-1]-sums-tmp_max)
              max_val = max(-nums[-1]-sums-tmp_min, -nums[-1]+sums+tmp_max)
          nums = []
      elif a!="+":
          nums.append(int(a))
      print(a, min_val, max_val)
          
  return sum(nums)+max_val
```
정확성  테스트
```
테스트 1 〉	통과 (0.03ms, 10.3MB)
테스트 2 〉	통과 (0.03ms, 10.4MB)
테스트 3 〉	통과 (0.02ms, 10.2MB)
테스트 4 〉	통과 (0.03ms, 10.3MB)
테스트 5 〉	통과 (0.03ms, 10.3MB)
테스트 6 〉	통과 (0.03ms, 10.4MB)
테스트 7 〉	통과 (0.03ms, 10.3MB)
테스트 8 〉	통과 (0.03ms, 10.4MB)
테스트 9 〉	통과 (0.02ms, 10.4MB)
테스트 10 〉	통과 (0.02ms, 10.2MB)
```
효율성  테스트
```
테스트 1 〉	통과 (2.73ms, 10.3MB)
테스트 2 〉	통과 (2.07ms, 10.1MB)
테스트 3 〉	통과 (1.85ms, 10.3MB)
테스트 4 〉	통과 (2.07ms, 10.3MB)
테스트 5 〉	통과 (0.04ms, 10.3MB)
테스트 6 〉	통과 (3.38ms, 10.1MB)
테스트 7 〉	통과 (1.98ms, 10.1MB)
테스트 8 〉	통과 (3.04ms, 10.1MB)
```
