# 풍선 터트리기
## 문제 설명
일렬로 나열된 n개의 풍선이 있습니다. 모든 풍선에는 서로 다른 숫자가 써져 있습니다. 당신은 다음 과정을 반복하면서 풍선들을 단 1개만 남을 때까지 계속 터트리려고 합니다.

1. 임의의 인접한 두 풍선을 고른 뒤, 두 풍선 중 하나를 터트립니다.
2. 터진 풍선으로 인해 풍선들 사이에 빈 공간이 생겼다면, 빈 공간이 없도록 풍선들을 중앙으로 밀착시킵니다.

여기서 조건이 있습니다. 인접한 두 풍선 중에서 **번호가 더 작은 풍선**을 터트리는 행위는 최대 1번만 할 수 있습니다. 즉, 어떤 시점에서 인접한 두 풍선 중 번호가 더 작은 풍선을 터트렸다면, 그 이후에는 인접한 두 풍선을 고른 뒤 번호가 더 큰 풍선만을 터트릴 수 있습니다.

당신은 어떤 풍선이 최후까지 남을 수 있는지 알아보고 싶습니다. 위에 서술된 조건대로 풍선을 터트리다 보면, 어떤 풍선은 최후까지 남을 수도 있지만, 어떤 풍선은 무슨 수를 쓰더라도 마지막까지 남기는 것이 **불가능**할 수도 있습니다.

일렬로 나열된 풍선들의 번호가 담긴 배열 a가 주어집니다. 위에 서술된 규칙대로 풍선들을 1개만 남을 때까지 터트렸을 때 최후까지 남기는 것이 가능한 풍선들의 개수를 return 하도록 solution 함수를 완성해주세요.

## 제한 사항
- a의 길이는 1 이상 1,000,000 이하입니다.
  - `a[i]`는 i+1 번째 풍선에 써진 숫자를 의미합니다.
  - a의 모든 수는 -1,000,000,000 이상 1,000,000,000 이하인 정수입니다.
  - a의 모든 수는 서로 다릅니다.
  
## 입출력 예
|a|result|
|-|-|
|[9,-1,-5]|3|
|[-16,27,65,-2,58,-92,-71,-68,-61,-33]|6|

## 입출력 예 설명
### 입출력 예 #1

- 첫 번째 풍선(9가 써진 풍선)을 최후까지 남기는 방법은 다음과 같습니다.
  1. `[9, -1, -5]` 에서 -1, -5가 써진 풍선을 고른 뒤, -1이 써진 풍선(번호가 더 큰 것)을 터트립니다.
  2. `[9, -5]` 에서 9, -5가 써진 풍선을 고른 뒤, -5가 써진 풍선(번호가 더 작은 것)을 터트립니다.
- 두 번째 풍선(-1이 써진 풍선)을 최후까지 남기는 방법은 다음과 같습니다.
  1. `[9, -1, -5]` 에서 9, -1이 써진 풍선을 고른 뒤, 9가 써진 풍선(번호가 더 큰 것)을 터트립니다.
  2. `[-1, -5]` 에서 -1, -5가 써진 풍선을 고른 뒤, -5가 써진 풍선(번호가 더 작은 것)을 터트립니다.
- 세 번째 풍선(-5가 써진 풍선)을 최후까지 남기는 방법은 다음과 같습니다.
  1. `[9, -1, -5]` 에서 9, -1이 써진 풍선을 고른 뒤, 9가 써진 풍선(번호가 더 큰 것)을 터트립니다.
  2. `[-1, -5]` 에서 -1, -5가 써진 풍선을 고른 뒤, -1이 써진 풍선(번호가 더 큰 것)을 터트립니다.
- 3개의 풍선이 최후까지 남을 수 있으므로, 3을 return 해야 합니다.

## 입출력 예 #2
- 최후까지 남을 수 있는 풍선은 -16, -92, -71, -68, -61, -33이 써진 풍선으로 모두 6개입니다.

# 내 풀이
```python
def solution(a):
    l = len(a)
    min_val = min(a)
    min_ind = a.index(min_val)
    answer=1
    
    if min_ind==1:
        answer+=1
    elif min_ind>1:
        answer+=1
        l_a = a[:min_ind]
        l_min = min(l_a)
        l_ind = l_a.index(l_min)
        if l_ind>0:
            for i in range(l_ind-1, -1, -1):
                if l_a[i]>l_min:
                    l_min = l_a[i]
                    answer+=1
            
    if min_ind==l-2:
        answer+=1
    elif min_ind<l-2:
        answer+=1
        r_a = a[min_ind+1:]
        r_min = min(r_a)
        r_ind = r_a.index(r_min)
        if r_ind<len(r_a)-1:
            for i in range(r_ind+1, len(r_a)):
                if r_a[i]>r_min:
                    r_min = r_a[i]
                    answer+=1
                    
    return answer
```
정확성  테스트
```
테스트 1 〉	통과 (0.01ms, 10.4MB)
테스트 2 〉	통과 (0.01ms, 10.1MB)
테스트 3 〉	실패 (0.17ms, 10.1MB)
테스트 4 〉	실패 (8.61ms, 14.3MB)
테스트 5 〉	실패 (84.29ms, 32.9MB)
테스트 6 〉	실패 (72.36ms, 44.8MB)
테스트 7 〉	실패 (146.74ms, 56.1MB)
테스트 8 〉	실패 (162.43ms, 56MB)
테스트 9 〉	실패 (144.00ms, 56.1MB)
테스트 10 〉	실패 (126.76ms, 56.1MB)
테스트 11 〉	통과 (167.01ms, 56.2MB)
테스트 12 〉	실패 (147.14ms, 56.2MB)
테스트 13 〉	실패 (150.09ms, 56.1MB)
테스트 14 〉	실패 (105.30ms, 56.1MB)
테스트 15 〉	실패 (152.57ms, 56MB)
```
- 규칙 찾기가 어려웠고 결국 찾은 줄 알았지만, 몇 개의 케이스에서만 성공했다.
- 전략
  - 번호가 큰 풍선들만 터트리다 보면, 가장 작은 번호의 풍선은 무조건 가능하다.
  - 양쪽 맨 끝의 풍선은, 번호가 최소인 풍선이 나머지를 다 터트려주고, 마지막에 번호가 작은 풍선을 터트리면 가능하다.
  - 최솟값의 풍선에 대해, 자신을 제외한 왼쪽과 오른쪽 각각에서 최소의 풍선을 찾고, 그 곳에서 바깥 방향으로 그 값보다 값이 큰 풍선들은 가능하다고 생각했다.
  - 이 방법은 결국 맞지 않음을 깨달았고, 결국 다른 사람의 풀이를 참고함

# 다른 사람의 풀이1
```python
def solution(a):
    answer = 2
    
    dp = [[0 for _ in range(len(a))] for _ in range(2)]
    dp[0][0] = a[0]
    dp[1][-1] = a[-1]
    
    for i in range(1,len(a)):
        dp[0][i] = min(dp[0][i-1],a[i])
        
    for i in range(len(a)-2,-1,-1):
        dp[1][i] = min(dp[1][i+1],a[i])
        
    for i in range(1, len(a)-1):
        if dp[0][i-1]<a[i]<dp[1][i+1] or dp[0][i-1]>a[i]>dp[1][i+1] or dp[0][i-1]>a[i]<dp[1][i+1]:
            answer+=1
    
    return answer
```
- 전략
  - 내 풀이의 1, 2번째 전략은 동일하다.
  - 세 번째 전략은, 최솟값이 아닌 특정 풍선에 대하여, 한 쪽으로 자신보다 값이 큰 풍선들만 있으면 가능하다.
    - 그 쪽의 풍선들은 자신이 모두 정리하고, 반대쪽의 풍선들은 최솟값을 갖는 풍선이 정리해주며, 마지막 1:1에서 번호가 작은 풍선을 터트리면 됨
  - 매 원소마다 min값을 구하면 시간초과가 나므로, dp를 이용해 왼쪽과 오른쪽에서 최솟값을 미리 구해놓고, 비교시에 불러온다.
 
# 다른 사람의 풀이2
```python
def solution(a):
    answer = 1
    M = min(a)
    for _ in range(2):
        m = a[0]
        i = 1
        while m != M:
            if m >= a[i]:
                m = a[i]
                answer += 1
            i += 1
        a.reverse()
    return answer
```
- 비슷한 전략으로 매우 간단한 풀이
- 양 쪽 끝에서부터 최소값까지 갈 때, 현재 까지의 최솟 값보다 더 작은 값이 나오면 answer+=1
