# 거스름돈
## 문제 설명
Finn은 편의점에서 야간 아르바이트를 하고 있습니다. 야간에 손님이 너무 없어 심심한 Finn은 손님들께 거스름돈을 n 원을 줄 때 방법의 경우의 수를 구하기로 하였습니다.

예를 들어서 손님께 5원을 거슬러 줘야 하고 1원, 2원, 5원이 있다면 다음과 같이 4가지 방법으로 5원을 거슬러 줄 수 있습니다.

- 1원을 5개 사용해서 거슬러 준다.
- 1원을 3개 사용하고, 2원을 1개 사용해서 거슬러 준다.
- 1원을 1개 사용하고, 2원을 2개 사용해서 거슬러 준다.
- 5원을 1개 사용해서 거슬러 준다.

거슬러 줘야 하는 금액 n과 Finn이 현재 보유하고 있는 돈의 종류 money가 매개변수로 주어질 때, Finn이 n 원을 거슬러 줄 방법의 수를 return 하도록 solution 함수를 완성해 주세요.

## 제한 사항
- n은 100,000 이하의 자연수입니다.
- 화폐 단위는 100종류 이하입니다.
- 모든 화폐는 무한하게 있다고 가정합니다.
- 정답이 커질 수 있으니, 1,000,000,007로 나눈 나머지를 return 해주세요.

## 입출력 예
|n|money|result|
|-|-|-|
|5|[1,2,5]|4|

## 입출력 예 설명
### 입출력 예 #1
문제의 예시와 같습니다.

# 내 풀이
```python
def solution(n, money):
    money = sorted(money)
    if money[0]>n: return 0
    for i, m in enumerate(money):
        if m>n:
            money = money[:i]
            break
    
    dp = [0 for _ in range(n+1)]
    
    for m in money:
        dp[m]+=1
        for i in range(m+1, n+1):
            dp[i]+=dp[i-m]
    
    return dp[-1]%1000000007
```
정확성  테스트
```
테스트 1 〉	통과 (4.05ms, 10.2MB)
테스트 2 〉	통과 (4.94ms, 10.3MB)
테스트 3 〉	통과 (1.45ms, 10.2MB)
테스트 4 〉	통과 (4.53ms, 10.3MB)
테스트 5 〉	통과 (3.29ms, 10.3MB)
테스트 6 〉	통과 (1.03ms, 10.1MB)
테스트 7 〉	통과 (6.51ms, 10.1MB)
테스트 8 〉	통과 (7.28ms, 10.3MB)
테스트 9 〉	통과 (3.77ms, 10.1MB)
테스트 10 〉	통과 (2.03ms, 10.2MB)
테스트 11 〉	통과 (3.51ms, 10.1MB)
테스트 12 〉	통과 (2.49ms, 10.2MB)
테스트 13 〉	통과 (0.94ms, 10.3MB)
테스트 14 〉	통과 (3.84ms, 10.2MB)
```
효율성  테스트
```
테스트 1 〉	통과 (251.92ms, 11MB)
테스트 2 〉	통과 (346.77ms, 12MB)
테스트 3 〉	통과 (241.93ms, 11.5MB)
테스트 4 〉	통과 (256.02ms, 11MB)
테스트 5 〉	통과 (456.44ms, 13.3MB)
테스트 6 〉	통과 (353.85ms, 12.1MB)
```
- 보자마자 dp일 것 같았다. (`n`이 너무 크다 + 경우의 수)
- 전략
  - `dp[i]`는 `i`를 거슬러 줘야 하는 경우의 수
  - 우선 `money`를 오름차순으로 정렬 & 거스름돈 보다 큰 단위의 돈은 정리
  - `money`에서 단위가 작은 돈부터 시작해서, 각 경우의 수를 업데이트
    - `money`의 한 원소 `m`을 볼 때, `dp[i+m] += dp[i]`를 이용
    - `dp[i]`의 경우의 수 각각에 `m`을 추가한 것이 `dp[i+m]`의 경우의 수가 된다.

# 다른 사람의 풀이
```python
def solution(total, coin):
    arr = [1] + [0]*total
    for c in coin:
        for i in range(c, total+1):
            arr[i] += arr[i-c]
    return arr.pop()
```
- 마찬가지로 dp이긴 하지만, 내 풀이 처음에 거스름돈보다 큰 돈은 제외하는 과정은 어차피 for문에서 알아서 제외된다.
  - `money`의 sorting 과정은 깐깐하게 봤을땐 필요해 보인다.
