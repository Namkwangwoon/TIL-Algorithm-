# 징검다리
## 문제 설명
출발지점부터 distance만큼 떨어진 곳에 도착지점이 있습니다. 그리고 그사이에는 바위들이 놓여있습니다. 바위 중 몇 개를 제거하려고 합니다.
예를 들어, 도착지점이 25만큼 떨어져 있고, 바위가 [2, 14, 11, 21, 17] 지점에 놓여있을 때 바위 2개를 제거하면 출발지점, 도착지점, 바위 간의 거리가 아래와 같습니다.

|제거한 바위의 위치|각 바위 사이의 거리|거리의 최솟값|
|-|-|-|
|[21, 17]|[2, 9, 3, 11]|2|
|[2, 21]|[11, 3, 3, 8]|3|
|[2, 11]|[14, 3, 4, 4]|3|
|[11, 21]|[2, 12, 3, 8]|2|
|[2, 14]|[11, 6, 4, 4]|4|

위에서 구한 거리의 최솟값 중에 가장 큰 값은 4입니다.

출발지점부터 도착지점까지의 거리 distance, 바위들이 있는 위치를 담은 배열 rocks, 제거할 바위의 수 n이 매개변수로 주어질 때, 바위를 n개 제거한 뒤 각 지점 사이의 거리의 최솟값 중에 가장 큰 값을 return 하도록 solution 함수를 작성해주세요.

## 제한사항
- 도착지점까지의 거리 distance는 1 이상 1,000,000,000 이하입니다.
- 바위는 1개 이상 50,000개 이하가 있습니다.
- n 은 1 이상 바위의 개수 이하입니다.

## 입출력 예
|distance|rocks|n|return|
|-|-|-|-|
|25|[2, 14, 11, 21, 17]|2|4|

## 입출력 예 설명
문제에 나온 예와 같습니다.

# 내 풀이
- 거리의 최솟값을 이분탐색으로 찾기 위해, 최소 1, 최대 25에서 시작해서 찾아야겠다는 생각은 했다.
- 그 이후로는 도저히 모르겠어서 다른 사람의 풀이를 참조
```python
def solution(distance, rocks, n):
    answer = 0
    rocks = sorted(rocks) + [distance]
    
    l, r = 1, distance
    
    while l<=r:
        m = (l+r)//2
        
        prev, delete = 0, 0
        for rock in rocks:
            if rock-prev>=m:
                prev = rock
            else:
                delete+=1
        
        if delete>n:
            r = m-1
        else:
            answer = m
            l = m+1
        
    return answer
```
정확성  테스트
```
테스트 1 〉	통과 (0.31ms, 10.2MB)
테스트 2 〉	통과 (0.19ms, 10.1MB)
테스트 3 〉	통과 (0.40ms, 10.1MB)
테스트 4 〉	통과 (8.81ms, 10.3MB)
테스트 5 〉	통과 (8.21ms, 10.3MB)
테스트 6 〉	통과 (96.30ms, 12.8MB)
테스트 7 〉	통과 (211.50ms, 12.5MB)
테스트 8 〉	통과 (125.24ms, 12.7MB)
테스트 9 〉	통과 (0.01ms, 10.1MB)
테스트 10 〉	통과 (0.01ms, 9.98MB)
테스트 11 〉	통과 (0.03ms, 10.2MB)
테스트 12 〉	통과 (0.03ms, 10.3MB)
테스트 13 〉	통과 (0.01ms, 10.1MB)
테스트 14 〉	통과 (0.02ms, 10.3MB)
테스트 15 〉	통과 (0.01ms, 10.2MB)
테스트 16 〉	통과 (0.03ms, 10.3MB)
테스트 17 〉	통과 (0.04ms, 10.2MB)
테스트 18 〉	통과 (0.02ms, 10.2MB)
테스트 19 〉	통과 (0.04ms, 10.1MB)
테스트 20 〉	통과 (102.39ms, 12MB)
테스트 21 〉	통과 (8.76ms, 10.3MB)
테스트 22 〉	통과 (69.36ms, 11.8MB)
테스트 23 〉	통과 (76.75ms, 11.1MB)
테스트 24 〉	통과 (166.29ms, 12.7MB)
테스트 25 〉	통과 (13.59ms, 10.3MB)
테스트 26 〉	통과 (39.17ms, 10.9MB)
테스트 27 〉	통과 (73.46ms, 11.4MB)
테스트 28 〉	통과 (4.92ms, 10.3MB)
테스트 29 〉	통과 (16.41ms, 10.5MB)
테스트 30 〉	통과 (38.56ms, 10.8MB)
테스트 31 〉	통과 (136.07ms, 12.2MB)
테스트 32 〉	통과 (7.12ms, 10.4MB)
테스트 33 〉	통과 (63.95ms, 11.4MB)
테스트 34 〉	통과 (148.29ms, 12.8MB)
테스트 35 〉	통과 (7.10ms, 10.4MB)
테스트 36 〉	통과 (57.14ms, 11.1MB)
테스트 37 〉	통과 (2.13ms, 10.2MB)
테스트 38 〉	통과 (3.84ms, 10.3MB)
테스트 39 〉	통과 (99.86ms, 11.9MB)
```
- 이 문제에서도 역시 answer = mid를 어디에서 줘야 할지가 매우 중요했다.
- 그 전 문제에서와 answer = m이 붙는 위치가 다르다,, delete = n 일때의 처리가 중요해 보인다.
- **(answer=n)을 최솟값을 요구하는 문제이면 r=m-1 조건문에, 최댓값을 요구하는 문제이면 l=m+1 조건문에 넣어주면 된다!**
