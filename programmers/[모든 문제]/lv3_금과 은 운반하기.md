# 금과 은 운반하기
## 문제 설명
어느 왕국에 하나 이상의 도시들이 있습니다. 왕국의 왕은 새 도시를 짓기로 결정하였습니다. 해당 도시를 짓기 위해서는 도시를 짓는 장소에 금 `a` kg과 은 `b` kg이 전달되어야 합니다.

각 도시에는 번호가 매겨져 있는데, `i`번 도시에는 금 `g[i]` kg, 은 `s[i]` kg, 그리고 트럭 한 대가 있습니다. `i`번 도시의 트럭은 오직 새 도시를 짓는 건설 장소와 `i`번 도시만을 왕복할 수 있으며, 편도로 이동하는 데 `t[i]` 시간이 걸리고, 최대 `w[i]` kg 광물을 운반할 수 있습니다. (광물은 금과 은입니다. 즉, 금과 은을 동시에 운반할 수 있습니다.) 모든 트럭은 같은 도로를 여러 번 왕복할 수 있으며 연료는 무한대라고 가정합니다.

정수 `a`, `b`와 정수 배열 `g`, `s`, `w`, `t`가 매개변수로 주어집니다. 주어진 정보를 바탕으로 각 도시의 트럭을 최적으로 운행했을 때, 새로운 도시를 건설하기 위해 금 `a` kg과 은 `b` kg을 전달할 수 있는 가장 빠른 시간을 구해 return 하도록 solution 함수를 완성해주세요.

## 제한사항
- 0 ≤ `a`, `b` ≤ $10^9$
- 1 ≤ `g`의 길이 = `s`의 길이 = `w`의 길이 = `t`의 길이 = 도시 개수 ≤ $10^5$
  - 0 ≤ `g[i]`, `s[i]` ≤ $10^9$
  - 1 ≤ `w[i]` ≤ $10^2$
  - 1 ≤ `t[i]` ≤ $10^5$
  - `a` ≤ `g`의 모든 수의 합
  - `b` ≤ `s`의 모든 수의 합

## 입출력 예
|a|b|g|s|w|t|result|
|-|-|-|-|-|-|-|
|10|10|[100]|[100]|[7]|[10]|50|
|90|500|[70,70,0]|[0,0,500]|[100,100,2]|[4,8,1]|499|

## 입출력 예 설명
### 입출력 예 #1

- 도시가 오직 하나뿐이므로, 0번 도시의 유일한 트럭이 모든 운반을 해결해야 합니다. 이 트럭은 최대 7kg만큼의 광물을 운반할 수 있으며 편도 완주에는 10시간이 걸립니다.
- 맨 처음에 10시간을 써서 7kg만큼의 금을 운반하고, 10시간을 써서 다시 도시로 돌아오고, 10시간을 써서 7kg만큼의 은을 운반하고, 10시간을 써서 다시 도시로 돌아오고, 마지막으로 10시간을 써서 3kg만큼의 금과 3kg만큼의 은을 운반하면, 총 50시간 만에 필요한 모든 금과 은을 조달할 수 있습니다.
- 따라서, 50을 return 해야 합니다.

### 입출력 예 #2

- 도시가 3개이고, 0번과 1번 도시는 금만 70kg씩 가지고 있고 2번 도시는 은을 500kg 가지고 있습니다.
  - 0번 도시의 트럭은 용량은 100kg, 편도 완주 시간은 4시간입니다.
  - 1번 도시의 트럭은 용량은 100kg, 편도 완주 시간은 8시간입니다.
  - 2번 도시의 트럭은 용량은 2kg, 편도 완주 시간은 1시간입니다.
- 금은 0번 도시의 트럭과 1번 도시의 트럭이 각각 45kg씩 나누어서 운반하면 8시간 안에 필요한 모든 금을 조달할 수 있습니다.
- 은은 2번 도시의 트럭이 한 번에 2kg씩 250번 운반하면(249번 왕복 + 1번 편도) 총 499시간 만에 필요한 모든 은을 조달할 수 있습니다.
- 따라서, 499를 return 해야 합니다.

# 다른 사람의 풀이
```python
def solution(a, b, g, s, w, t):
    answer = (10**9) * (10**5) * 4
    
    start = 0
    # 최악의 경우
    # 걸리는 최소시간(왕복) : 2 
    # 금 따로 은 따로(한도시에 금,은만 있을경우) : 2
    # 광물의 최대무게 : 10**9
    # 도시의 최대개수 : 10**5
    end = (10**9) * (10**5) * 4
    
    while start <= end:
        mid = (start + end) // 2
        gold = 0
        silver = 0 
        total = 0
        
        for i in range(len(g)):
            # 현재 정보
            now_gold = g[i]
            now_silver = s[i]
            now_weight = w[i]
            now_time = t[i]
            
            # 주어진 시간내에서 이동할 수 있는 횟수(왕복으로 계산)
            move_cnt = mid // (now_time * 2)
            
            # 편도 추가
            if mid % (now_time * 2) >= now_time:
                move_cnt += 1
                
            gold += now_gold if (now_gold < move_cnt * now_weight) else move_cnt * now_weight 
            silver += now_silver if (now_silver < move_cnt * now_weight) else move_cnt * now_weight
            total += now_gold + now_silver if (now_gold + now_silver < move_cnt * now_weight) else move_cnt * now_weight 
        
        if gold >= a and silver >= b and total >= a + b:
            end = mid - 1
            answer = min(answer, mid)
        else:
            start = mid + 1
        
    return answer
```
- 이분탐색일 것이라고 떠올렸지만, 도저히 풀이가 생각나지 않았다. (손도 못댔다.)
- 아래의 경우도 생각을 해보았지만, 정답 만족 조건(금, 은, 금+은 모두가 목표량보다 이상이어야 함)을 생각하지 못해서 결국 실패
- 전략
  - 가장 빠른 시간을 찾는 것이 목표이므로, `l`, `r`, `mid`는 시간을 나타냄
    - 최대 범위 `r`은 최악의 경우: `a`와 `b` 각각에 대해, 가장 큰 값을 가지며 운반할 수 있는 양 `w`은 가장 작고 걸리는 시간 `t`는 가장 큰 경우
      - 2 * (a / w) * 2t => 2 * ($10^9$ / 1) * 2 * $10^5$ = 4 * $10^{14}$
  - 위 값들을 갖고 이분 탐색
    - 먼저 각 도시에 대한 값들을 기반으로 실어 나를 수 있는 총 횟수를 구함
    - 각 횟수로 실어 나를 수 있는 금, 은, 금+은의 양 누적
    - 해당 시간 `mid`가 주어졌을 때, 실어 나를 수 있는 금, 은, 금+은의 최대 양은, 최소한 목표 금, 은, 금+은 양보다는 커야 함
      - 이 범위 안에서 정답이 존재할 수 있음
      - 해당 시간에서 아무리 최대로 실어 날라도 목표를 하나라도 채우지 못하면, 말이 안되는 경우임

# 내 풀이
```python
def solution(a, b, g, s, w, t):
    l, r = 0, 4*10**14
    l_city = len(g)
    answer = float('inf')
    
    while l<=r:
        mid = (l+r)//2  # 걸리는 총 시간
        gold = 0    # 가능한 금의 최대 갯수
        silver = 0  # 가능한 은의 최대 갯수
        sums = 0    # 가능한 금+은의 최대 갯수
        
        for i in range(l_city):
            n = mid//(2*t[i]) # 운반 가능 횟수
            if mid%(2*t[i])>=t[i]: n+=1 # 편도가 가능하면 한 번 더 운반 가능
            gold += min(g[i], n*w[i])
            silver += min(s[i], n*w[i])
            sums += min(s[i]+g[i], n*w[i])
            
        if a<=gold and b<=silver and a+b<=sums: # (금), (은), (금+은)모두의 최대가 무조건 목표량보다 많아야 함
            r = mid-1
            answer = min(answer, mid)
        else:
            l = mid+1
            
    return answer
```
정확성  테스트
```
테스트 1 〉	통과 (0.08ms, 10.2MB)
테스트 2 〉	통과 (0.09ms, 10.2MB)
테스트 3 〉	통과 (0.13ms, 10.2MB)
테스트 4 〉	통과 (0.19ms, 10.3MB)
테스트 5 〉	통과 (0.50ms, 10.3MB)
테스트 6 〉	통과 (0.99ms, 10.3MB)
테스트 7 〉	통과 (1.51ms, 10.3MB)
테스트 8 〉	통과 (4.63ms, 10.2MB)
테스트 9 〉	통과 (10.57ms, 10.3MB)
테스트 10 〉	통과 (13.32ms, 10.1MB)
테스트 11 〉	통과 (485.60ms, 11.3MB)
테스트 12 〉	통과 (1018.59ms, 12.6MB)
테스트 13 〉	통과 (1501.03ms, 13.7MB)
테스트 14 〉	통과 (1830.44ms, 15.1MB)
테스트 15 〉	통과 (2424.05ms, 16.3MB)
테스트 16 〉	통과 (3006.75ms, 17.6MB)
테스트 17 〉	통과 (4526.15ms, 21.2MB)
테스트 18 〉	통과 (4532.87ms, 22.2MB)
테스트 19 〉	통과 (4428.55ms, 22.3MB)
테스트 20 〉	통과 (4958.74ms, 22.2MB)
테스트 21 〉	통과 (5068.69ms, 22.2MB)
테스트 22 〉	통과 (4762.69ms, 22.2MB)
테스트 23 〉	통과 (4702.41ms, 22.2MB)
테스트 24 〉	통과 (0.08ms, 10.3MB)
```
