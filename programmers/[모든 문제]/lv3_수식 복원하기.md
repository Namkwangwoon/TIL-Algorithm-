# 수식 복원하기
## 문제 설명
당신은 덧셈 혹은 뺄셈 수식이 여러 개 적힌 고대 문명의 유물을 찾았습니다. 이 수식들을 관찰하던 당신은 이 문명이 사용하던 진법 체계가 10진법이 아니라는 것을 알아냈습니다. (2 ~ 9진법 중 하나입니다.)

수식들 중 몇 개의 수식은 결괏값이 지워져 있으며, 당신은 이 문명이 사용하던 진법에 맞도록 지워진 결괏값을 채워 넣으려 합니다.

다음은 그 예시입니다.

**<수식>**
```
14 + 3 = 17
13 - 6 = X
51 - 5 = 44
```
- `X`로 표시된 부분이 지워진 결괏값입니다.

`51 - 5 = 44`에서 이 문명이 사용하던 진법이 8진법임을 알 수 있습니다. 따라서 `13 - 6 = X`의 지워진 결괏값을 채워 넣으면 `13 - 6 = 5`가 됩니다.

다음은 또 다른 예시입니다.

**<수식>**
```
1 + 1 = 2
1 + 3 = 4
1 + 5 = X
1 + 2 = X
```
주어진 수식들에서 이 문명에서 사용한 진법이 6 ~ 9진법 중 하나임을 알 수 있습니다.
`1 + 5 = X`의 결괏값은 6진법일 때 10, 7 ~ 9진법일 때 6이 됩니다. 이와 같이 결괏값이 불확실한 수식은 `?`를 사용해 `1 + 5 = ?`와 같이 결괏값을 채워 넣습니다.
`1 + 2 = X`의 결괏값은 6 ~ 9진법에서 모두 3으로 같습니다. 따라서 `1 + 2 = X`의 지워진 결괏값을 채워 넣으면 `1 + 2 = 3`이 됩니다.

덧셈 혹은 뺄셈 수식들이 담긴 1차원 문자열 배열 `expressions`가 매개변수로 주어집니다. 이때 결괏값이 지워진 수식들의 결괏값을 채워 넣어 순서대로 문자열 배열에 담아 return 하도록 solution 함수를 완성해 주세요.

## 제한사항
- 2 ≤ `expressions`의 길이 ≤ 100
  - `expressions`의 원소는 `"A + B = C"` 혹은 `"A - B = C"` 형태의 문자열입니다. A, B, C와 연산 기호들은 공백 하나로 구분되어 있습니다.
  - A, B는 음이 아닌 두 자릿수 이하의 정수입니다.
  - C는 알파벳 `X` 혹은 음이 아닌 세 자릿수 이하의 정수입니다. C가 알파벳 `X`인 수식은 결괏값이 지워진 수식을 의미하며, 이러한 수식은 한 번 이상 등장합니다.
  - 결괏값이 음수가 되거나 서로 모순되는 수식은 주어지지 않습니다.
  
## 입출력 예
|expressions|result|
|-|-|
|["14 + 3 = 17", "13 - 6 = X", "51 - 5 = 44"]|["13 - 6 = 5"]|
|["1 + 1 = 2", "1 + 3 = 4", "1 + 5 = X", "1 + 2 = X"]|["1 + 5 = ?", "1 + 2 = 3"]|
|["10 - 2 = X", "30 + 31 = 101", "3 + 3 = X", "33 + 33 = X"]|["10 - 2 = 4", "3 + 3 = 10", "33 + 33 = 110"]|
|["2 - 1 = 1", "2 + 2 = X", "7 + 4 = X", "5 - 5 = X"]|["2 + 2 = 4", "7 + 4 = ?", "5 - 5 = 0"]|
|["2 - 1 = 1", "2 + 2 = X", "7 + 4 = X", "8 + 4 = X"]|["2 + 2 = 4", "7 + 4 = 12", "8 + 4 = 13"]|

## 입출력 예 설명
### 입출력 예 #1

문제 예시와 같습니다.

### 입출력 예 #2

문제 예시와 같습니다.

### 입출력 예 #3

`30 + 31 = 101`에서 이 문명이 사용하던 진법이 6진법임을 알 수 있습니다. 따라서 `10 - 2 = X`, `3 + 3 = X`, `33 + 33 = X`의 지워진 결괏값을 채워 넣으면 `10 - 2 = 4`, `3 + 3 = 10`, `33 + 33 = 110`이 됩니다.

따라서 `["10 - 2 = 4", "3 + 3 = 10", "33 + 33 = 110"]`을 return 해야 합니다.

### 입출력 예 #4

수식에 등장하는 숫자들을 통해 이 문명이 사용하던 진법이 8진법 혹은 9진법임을 알 수 있습니다. `2 + 2 = X`와 `5 - 5 = X`의 지워진 결괏값을 채워 넣으면 8진법, 9진법에 관계없이 `2 + 2 = 4`, `5 - 5 = 0`이 됩니다. `7 + 4 = X`의 결괏값은 불확실하므로 지워진 결괏값을 채워 넣으면 `7 + 4 = ?`가 됩니다.

따라서 `["2 + 2 = 4", "7 + 4 = ?", "5 - 5 = 0"]`을 return 해야 합니다.

입출력 예 #5

네 번째 예시와 같지만 `5 - 5 = X`가 `8 + 4 = X`로 바뀌었습니다. 이 문명이 사용하던 진법이 9진법임을 알 수 있으므로 `7 + 4 = X`와 `8 + 4 = X`의 지워진 결괏값을 채워 넣으면 `7 + 4 = 12`, `8 + 4 = 13`이 됩니다.

따라서 `["2 + 2 = 4", "7 + 4 = 12", "8 + 4 = 13"]`을 return 해야 합니다.

# 내 풀이
```python
def check_avail(avail_nums, A, op, B, RES):
    new_nums = []
    for num in avail_nums:
        new_a, new_b, new_res = num*A[0]+A[1], num*B[0]+B[1], (num**2)*RES[0]+num*RES[1]+RES[2]
        if op=='+':
            if new_a + new_b == new_res: new_nums.append(num)
        else:
            if new_a - new_b == new_res: new_nums.append(num)
    return new_nums
            
    
def filling(to_fill, avail_nums):
    answer = []
    for exp in to_fill:
        result_set = set()
        a, op, b, _, __ = exp.split()
        a, b = int(a), int(b)
        for num in avail_nums:
            A, B = [a//10, a%10], [b//10, b%10]
            new_a, new_b = A[0]*num+A[1], B[0]*num+B[1]
            if op=='+': new_res = new_a + new_b
            else: new_res = new_a - new_b
            RES = [new_res//(num**2), (new_res%(num**2))//num, new_res%num]
            result_set.add("".join(map(str, RES)))
            if len(result_set)==2:
                answer.append(" ".join([str(a), op, str(b), '=', '?']))
                break
        else:
            answer.append(" ".join([str(a), op, str(b), '=', str(int(list(result_set)[0]))]))
    return answer
    

def solution(expressions):
    min_num = 0
    to_fill = []
    avail_nums = [i for i in range(2, 10)]
    
    # 가능한 진법 찾기
    for expression in expressions:
        a, op, b, _, res = expression.split()
        a, b = int(a), int(b)
        A, B = [a//10, a%10], [b//10, b%10]
        if res!='X':
            res = int(res)
            RES = [res//100, (res%100)//10, res%10]
            min_num = max(min_num, max(A+B+RES)+1)
        else:
            min_num = max(min_num, max(A+B)+1)
            to_fill.append(expression)
            continue
            
        avail_nums = check_avail(avail_nums, A, op, B, RES)
    
    avail_nums = [n for n in avail_nums if n>=min_num]
    
    # '숫자' 혹은 '?' 채워넣기
    return filling(to_fill, avail_nums)
```
- 구현 문제
- 문제에 빠뜨린 개념이 있어서, 코딩하는 데에 시간이 꽤 오래 걸렸다.
- 전략
  - 크게 두 부분으로 나눔, (1) 가능한 진법 찾기 + 지워진 수식 따로 모으기 (2) 지워진 수식 채워넣기
      1. (가장 큰 자릿수 & 지워지지 않은 수식) 체크 => 가능한 진법들을 구함
      2. 지워진 수식에 가능한 진법들을 모두 시도하여, 'X'의 결과가 두 개 이상 나오면 '?'로, 한 개만 나오면 해당 수로 수식 재구성
- 다른 사람의 풀이에서, (1) 수식을 찾을 때, 수식 후보가 한 개로 좁혀지면 더 이상 후보를 찾는 과정을 거치지 않아도 됨
