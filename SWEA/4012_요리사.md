출처 : https://swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AWIeUtVakTMDFAVH&categoryId=AWIeUtVakTMDFAVH&categoryType=CODE&problemTitle=%EB%AA%A8%EC%9D%98&orderBy=PASS_RATE&selectCodeLang=PYTHON&select-1=&pageSize=10&pageIndex=1&&&&&&&&&

# 요리사
두 명의 손님에게 음식을 제공하려고 한다.

두 명의 손님은 식성이 비슷하기 때문에, 최대한 비슷한 맛의 음식을 만들어 내야 한다.

N개의 식재료가 있다.

식재료들을 각각 N / 2개씩 나누어 두 개의 요리를 하려고 한다. (N은 짝수이다.)

이때, 각각의 음식을 A음식, B음식이라고 하자.

비슷한 맛의 음식을 만들기 위해서는 A음식과 B음식의 맛의 차이가 최소가 되도록 재료를 배분해야 한다.

음식의 맛은 음식을 구성하는 식재료들의 조합에 따라 다르게 된다.

 

식재료 i는 식재료 j와 같이 요리하게 되면 궁합이 잘 맞아 시너지 Sij가 발생한다. (1 ≤ i ≤ N, 1 ≤ j ≤ N, i ≠ j)

각 음식의 맛은 음식을 구성하는 식재료들로부터 발생하는 시너지 Sij들의 합이다.

 

**식재료 i를 식재료 j와 같이 요리하게 되면 발생하는 시너지 Sij의 정보가 주어지고, 가지고 있는 식재료를 이용해 A음식과 B음식을 만들 때, 두 음식 간의 맛의 차이가 최소가 되는 경우를 찾고 그 최솟값을 정답으로 출력하는 프로그램을 작성하라.**

 

## [예시]

N = 4인 예를 생각해보자. 시너지 Sij는 [Table 1]과 같이 주어진다.

(세로축으로 i번째 위치에 있고 가로축으로 j번째 위치에 있는 값이 Sij이다.)

![download](https://github.com/Namkwangwoon/TIL-Algorithm-/assets/19163372/2e1fbc64-479e-40cd-a11f-b8089b192f75)
 
식재료 1과 식재료 2를 A음식으로 만들고 식재료 3과 식재료 4를 B음식으로 만드는 경우를 생각하자.

1) 식재료 1을 식재료 2와 같이 요리했을 때 발생하는 시너지 S12는 5이다.

2) 식재료 2를 식재료 1과 같이 요리했을 때 발생하는 시너지 S21는 4이다.

3) A음식의 맛은 5 + 4 = 9가 된다.

4) 식재료 3을 식재료 4와 같이 요리했을 때 발생하는 시너지 S34는 3이다.

5) 식재료 4를 식재료 3과 같이 요리했을 때 발생하는 시너지 S43은 3이다.

6) B음식의 맛은 3 + 3 = 6이 된다.

 
따라서, 두 음식 간의 맛의 차이는 |9 – 6| = 3이 된다.

 
식재료 2와 식재료 4를 A음식으로 만들고 식재료 1과 식재료 3을 B음식으로 만드는 경우를 생각하자.

 

7) 식재료 2를 식재료 4와 같이 요리했을 때 발생하는 시너지 S24는 1이다.

8) 식재료 4를 식재료 2와 같이 요리했을 때 발생하는 시너지 S42는 2이다.

9) A음식의 전력은 1 + 2 = 3이 된다.

10) 식재료 1을 식재료 3과 같이 요리했을 때 발생하는 시너지 S13은 3이다.

11) 식재료 3과 식재료 1을 같이 요리했을 때 발생하는 시너지 S31은 2이다.

12) B음식의 맛은 3 + 2 = 5가 된다.

 

따라서, 두 음식간의 맛의 차이는 |3 – 5| = 2가 된다.

이 경우가 A음식과 B음식 간의 맛의 차이가 최소인 경우이다.

다른 경우에서는 맛의 차이가 2보다 작을 수 없다.

따라서, 본 예의 정답은 2가 된다.

 

## [제약사항]

1. 시간 제한 : 최대 50개 테스트 케이스를 모두 통과하는 데 C / C++ / Java 모두 3초

2. 식재료의 수 N은 4이상 16이하의 짝수이다. (4 ≤ N ≤ 16)

3. 시너지 Sij는 1이상 20,000이하의 정수이다. (1 ≤ Sij ≤ 20,000, i ≠ j)

4. i와 j가 서로 같은 경우의 Sij값은 정의되지 않는다. 입력에서는 0으로 주어진다.

 

## [입력]

입력의 맨 첫 줄에는 총 테스트 케이스의 개수 T가 주어지고,

그 다음 줄부터 T개의 테스트 케이스가 주어진다.

각 테스트 케이스의 첫 번째 줄에는 식재료의 수 N이 주어진다.

다음 N개의 줄에는 N * N개의 시너지 Sij값들이 주어진다. i와 j가 서로 같은 경우는 0으로 주어진다.

 

## [출력]

테스트 케이스 개수만큼 T개의 줄에 각각의 테스트 케이스에 대한 답을 출력한다.

각 줄은 "#t"로 시작하고 공백을 하나 둔 다음 정답을 출력한다. (t 는 1부터 시작하는 테스트 케이스의 번호이다.)

정답은 두 음식 간의 맛의 차이가 최소가 되도록 A음식과 B음식을 만들었을 때 그 차이 값이다.


<details>
<summary>입력</summary>
  
```
10
4
0 5 3 8
4 0 4 1
2 5 0 3
7 2 3 0
4
0 7 1 1
7 0 6 2
1 1 0 2
10 1 9 0
6
0 37 26 52 77 20
32 0 15 26 75 16
54 33 0 79 37 90
92 10 66 0 92 3
64 7 89 89 0 21
80 49 94 68 5 0
6
0 73 30 81 27 94
98 0 91 9 97 24
51 100 0 35 41 98
26 26 96 0 26 90
73 37 39 57 0 16
90 88 97 9 95 0
8
0 410 87 281 463 41 192 191
65 0 93 26 402 367 22 222
90 408 0 108 179 457 248 369
151 466 13 0 189 426 405 376
219 207 351 256 0 361 73 207
381 453 11 113 165 0 164 499
121 325 328 428 459 386 0 146
286 98 334 430 230 263 252 0
10
0 229 257 895 817 917 144 864 51 242
795 0 519 281 868 100 653 995 722 756
190 106 0 547 996 469 195 734 928 629
897 72 601 0 905 823 551 590 934 727
612 255 431 453 0 126 303 926 731 96
913 385 951 218 399 0 510 726 343 457
174 790 862 336 367 311 0 646 436 806
578 842 294 863 436 614 602 0 951 462
655 791 752 672 228 444 611 833 0 64
517 115 573 42 250 879 58 79 372 0
10
0 56 720 377 134 665 214 238 313 92
446 0 600 840 363 581 393 620 94 135
699 515 0 353 340 569 186 185 138 28
473 706 797 0 896 37 241 690 928 117
945 336 416 765 0 711 504 609 387 934
218 712 229 75 179 0 187 473 713 726
948 369 811 401 853 728 0 185 880 310
219 507 998 961 638 810 68 0 776 679
748 650 779 20 471 338 443 91 0 465
441 504 159 579 302 783 208 994 531 0
12
0 3211 3086 1220 779 4353 3575 1412 835 2640 1242 1161
2510 0 3944 1817 1688 3226 2665 2764 802 1751 2815 526
2488 862 0 2517 345 2722 4315 1895 1877 3422 3824 4862
1192 2602 2931 0 129 3018 3317 2726 3682 4594 1407 3432
2031 4662 48 3043 0 209 2467 485 587 3179 2498 669
3854 4648 2878 454 2295 0 757 504 146 1292 3235 3190
4502 2314 702 3389 4671 3909 0 2430 2461 2023 1363 3879
4468 2095 58 3309 1448 2893 1290 0 2763 2130 2112 3787
1423 1713 4999 3973 3580 2411 3599 257 0 2806 3186 463
883 4270 3521 680 4171 564 4301 4748 3399 0 1824 3130
356 2745 4925 590 3370 1712 2737 2588 3552 2367 0 3724
3861 39 4639 132 916 4257 2545 642 377 1951 858 0
14
0 6759 419 8099 7845 4710 3475 1397 7405 1244 7354 5647 6006 1387
9802 0 3077 7064 1529 8966 8596 7348 8761 2943 104 750 4492 1211
4172 5855 0 517 2715 5271 7893 4242 8841 18 8665 1687 1297 6508
4298 5555 3509 0 8500 8064 7627 7653 8585 1695 9449 1831 5509 340
5791 3397 9348 3097 0 440 4476 7285 9915 4417 2600 2457 1809 3043
6905 4642 5300 1361 9838 0 1778 4926 512 4994 824 4156 4972 1487
1165 4974 721 3975 2272 3028 0 1127 3052 2649 6005 4245 1092 3540
2283 1097 7528 8376 1825 530 1123 0 641 8386 3981 9362 9051 1898
3693 8834 2530 1077 2396 5337 8038 6168 0 1344 8333 5492 987 679
9557 3610 3592 7376 3677 7215 5463 1592 6974 0 59 6715 8573 3622
5372 1217 9520 9330 5338 2435 1624 4886 2286 1058 0 3007 6893 1602
6361 5073 673 521 7996 4491 7009 2596 6194 220 9300 0 5746 1411
6673 9617 9615 2690 1211 3784 2154 3673 3699 8440 2745 1195 0 8535
5812 4670 7352 2441 263 6531 4064 4587 9550 7000 7277 7927 5908 0
16
0 12448 6851 12839 10088 11824 6821 10119 6108 6930 2380 10216 7905 6444 2390 13248
11368 0 11404 10531 2955 11818 17228 11793 6034 5489 5239 13543 9421 4753 19679 8599
11592 10967 0 1947 6713 11855 11304 13892 14691 1644 6715 17167 4385 15498 10846 15865
4737 16986 3146 0 19413 13972 13814 16926 5396 16933 6318 3673 6204 10758 8606 223
7210 2397 2096 8026 0 10205 3378 10634 8898 12625 5730 17013 18007 5278 16817 16818
12569 1682 5908 321 156 0 4689 4500 2968 14162 9031 7341 6294 19644 2559 8275
9134 9855 5450 3346 11592 14520 0 18028 11507 11108 14128 6344 5943 8042 1684 12742
7304 10662 13463 8644 19785 6461 4825 0 12040 6947 16847 17924 5905 1833 3255 19220
12302 14705 10055 6367 2225 3402 8514 13397 0 8717 13344 11467 17329 1117 6963 8024
433 12431 14312 5853 2467 2072 14751 1814 15040 0 17667 2599 1486 7260 15956 4840
12085 9224 8723 9544 15535 18215 5885 12911 10004 3055 0 4132 14774 11105 6251 9114
469 17345 5205 6913 11125 9119 14786 18919 10343 7059 9720 0 7474 14729 777 11395
10814 8066 7548 4719 3677 8709 2094 18512 10888 7842 14726 8472 0 14194 10911 5674
18825 15832 9303 6789 7976 8462 7447 5103 8639 5585 590 11623 1578 0 11490 10290
3762 11425 4275 1606 14768 14576 11508 15692 16910 4994 19442 11410 2866 4541 0 7425
6081 10373 12081 14518 10808 14188 1748 7938 16635 5209 1288 93 16247 8093 4349 0
```
</details>

<details>
<summary>출력</summary>
 
```
#1 2
#2 1
#3 38
#4 15
#5 4
#6 0
#7 51
#8 23
#9 13
#10 11
```
</details>

# 내 풀이
- SWEA를 써보라는 블로그 글을 봐서 처음 써봤는데, 좀 달라서 헤맸다.
  - 특히 itertools를 못 써서 백트래킹 방법 사용을 위해 다른 사람의 풀이 참고
```python
T = int(input())
result = None


def sums(s, maps):
    sums = 0
    l = len(s)
    for i in range(l - 1):
        for j in range(i + 1, l):
            sums += maps[s[i]][s[j]] + maps[s[j]][s[i]]
    return sums


def dfs(count, k, maps, N, visited):
    global result
    if count == N // 2:
        s1, s2 = [], []
        for i in range(N):
            if visited[i] == True:
                s1.append(i)
            else:
                s2.append(i)
        diff = abs(sums(s1, maps) - sums(s2, maps))
        if diff < result: result = diff

    for i in range(k, N):
        if visited[i] == False:
            visited[i] = True
            dfs(count + 1, i + 1, maps, N, visited)
            visited[i] = False


for t in range(1, T + 1):
    result = float('inf')
    N = int(input())
    maps = [list(map(int, input().split())) for _ in range(N)]
    visited = [False for _ in range(N)]

    dfs(0, 0, maps, N, visited)

    print("#%d" % t, result)
```
- 앞으로 백트래킹 문제가 많이 나오기 때문에, 익혀둬야겠다.
- 근데 찾아보니, `from itertools import combinations as com` 으로 하면 된다...
