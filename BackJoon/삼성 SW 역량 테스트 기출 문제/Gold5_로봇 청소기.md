# 로봇 청소기
## 문제
로봇 청소기와 방의 상태가 주어졌을 때, 청소하는 영역의 개수를 구하는 프로그램을 작성하시오.

로봇 청소기가 있는 방은 $N \times M$ 크기의 직사각형으로 나타낼 수 있으며, $1 \times 1$ 크기의 정사각형 칸으로 나누어져 있다. 각각의 칸은 벽 또는 빈 칸이다. 청소기는 바라보는 방향이 있으며, 이 방향은 동, 서, 남, 북 중 하나이다. 방의 각 칸은 좌표 $(r, c)$로 나타낼 수 있고, 가장 북쪽 줄의 가장 서쪽 칸의 좌표가  $(0, 0)$, 가장 남쪽 줄의 가장 동쪽 칸의 좌표가  $(N-1, M-1)$이다. 즉, 좌표  $(r, c)$는 북쪽에서  $(r+1)$번째에 있는 줄의 서쪽에서  $(c+1)$번째 칸을 가리킨다. 처음에 빈 칸은 전부 청소되지 않은 상태이다.

로봇 청소기는 다음과 같이 작동한다.

1. 현재 칸이 아직 청소되지 않은 경우, 현재 칸을 청소한다.
2. 현재 칸의 주변 $4$칸 중 청소되지 않은 빈 칸이 없는 경우,
   1. 바라보는 방향을 유지한 채로 한 칸 후진할 수 있다면 한 칸 후진하고 1번으로 돌아간다.
   2. 바라보는 방향의 뒤쪽 칸이 벽이라 후진할 수 없다면 작동을 멈춘다.
3. 현재 칸의 주변 $4$칸 중 청소되지 않은 빈 칸이 있는 경우,
   1. 반시계 방향으로 $90^\circ$ 회전한다.
   2. 바라보는 방향을 기준으로 앞쪽 칸이 청소되지 않은 빈 칸인 경우 한 칸 전진한다.
   3. 1번으로 돌아간다.
## 입력
첫째 줄에 방의 크기 $N$과 $M$이 입력된다. $(3 \le N, M \le 50)$ 둘째 줄에 처음에 로봇 청소기가 있는 칸의 좌표 $(r, c)$와 처음에 로봇 청소기가 바라보는 방향 $d$가 입력된다. $d$가 $0$인 경우 북쪽, $1$인 경우 동쪽, $2$인 경우 남쪽, $3$인 경우 서쪽을 바라보고 있는 것이다.

셋째 줄부터  $N$개의 줄에 각 장소의 상태를 나타내는 $N \times M$개의 값이 한 줄에 $M$개씩 입력된다. $i$번째 줄의 $j$번째 값은 칸 $(i, j)$의 상태를 나타내며, 이 값이 $0$인 경우 $(i, j)$가 청소되지 않은 빈 칸이고, $1$인 경우 $(i, j)$에 벽이 있는 것이다. 방의 가장 북쪽, 가장 남쪽, 가장 서쪽, 가장 동쪽 줄 중 하나 이상에 위치한 모든 칸에는 벽이 있다. 로봇 청소기가 있는 칸은 항상 빈 칸이다.

## 출력
로봇 청소기가 작동을 시작한 후 작동을 멈출 때까지 청소하는 칸의 개수를 출력한다.

### 예제 입력 1 
```
3 3
1 1 0
1 1 1
1 0 1
1 1 1
```
### 예제 출력 1 
```
1
```
### 예제 입력 2
```
11 10
7 4 0
1 1 1 1 1 1 1 1 1 1
1 0 0 0 0 0 0 0 0 1
1 0 0 0 1 1 1 1 0 1
1 0 0 1 1 0 0 0 0 1
1 0 1 1 0 0 0 0 0 1
1 0 0 0 0 0 0 0 0 1
1 0 0 0 0 0 0 1 0 1
1 0 0 0 0 0 1 1 0 1
1 0 0 0 0 0 1 1 0 1
1 0 0 0 0 0 0 0 0 1
1 1 1 1 1 1 1 1 1 1
```
예제 출력 2 
```
57
```
# 내 풀이
```python
from sys import stdin

N, M = map(int, stdin.readline().split())
r, c, d = map(int, stdin.readline().split())
maps = [list(map(int, stdin.readline().split())) for _ in range(N)]
answer = 0

direc = [(-1, 0), (0, -1), (1, 0), (0, 1)]

while True:
    if maps[r][c]==0:
        maps[r][c]=1
        answer+=1

    for i in range(1, 5):
        x, y = direc[(d+i)%4]
        if 0<=r+x<N and 0<=c+y<M and maps[r+x][c+y]==0:
            r+=x
            c+=y
            d = (d+i)%4
            maps[r][c] = 1
            answer+=1
            break
    else:
        if 0<=r-x<N and 0<=c-y<M:
            r-=x
            c-=y
        else: break

print(answer)
```
- 전략
  - 구현 문제이며, 문제를 꼼꼼하게 읽고 구현했다.
- 테스트 케이스에서는 계속 성공했지만, 제출 후 실패해서 결국은 다른 사람의 풀이를 참고

# 다른 사람의 풀이
```python
dr = [-1, 0, 1, 0]
dc = [0, 1, 0, -1]

n, m = map(int, input().split())
r, c, d = map(int, input().split())
arr = [list(map(int, input().split())) for _ in range(n)]
## 방문 쳌
visited = [[0]*m for _ in range(n)]

## 시작지 방문쳌 and 카운트!
visited[r][c] = 1
cnt = 1

while True:
    flag = 0            ## 아직 아무것도 청소 안했음!
    for _ in range(4):  ## 4방향을 돈다!
        d = (d+3) % 4   ## 왼쪽방향으로 한 칸 돌린다! 중요!!!!!1
        nr = r + dr[d]
        nc = c + dc[d]

        ## 범위 안에 들고, 빈 칸이고, 청소할 수 있다면!
        ## 들려서 청소하고, 카운트하고, 현재 위치를 갱신하고, flag 변경!
        if 0 <= nr < n and 0 <= nc < m and arr[nr][nc] == 0:
            if visited[nr][nc] == 0:
                visited[nr][nc] = 1
                cnt += 1
                r = nr
                c = nc
                flag = 1        ## 청소 했다는 뜻
                break

    if flag == 0:               ## 위의 for문에 들어가지 못했을 때
        ## 즉 네 방향 모두 청소를 할 수 없을 때
        ## 후진 했을 때 벽이면 break
        ## 만약 뒤가 벽이 아니라면! 그 위치를 다시 갱신!!!
        if arr[r-dr[d]][c-dc[d]] == 1:
            print(cnt)
            break
        else:
            r, c = r-dr[d], c-dc[d]
```
- 청소를 한 칸을 1로 바꾸면 그 자리에 벽이 세워져 버리기 때문에 안된다.
  - 별도의 `visited` 2차원 배열을 만들어서, 벽이 아니고 `visited`가 0이면 청소를 하는 식으로 가야 한다.
  - 나중에 주변 4칸이 모두 청소되어 후진할 때, 벽이랑 청소한 칸을 다르게 인지해야 제대로 로봇 청소기가 멈추는 조건을 구별할 수 있다.
