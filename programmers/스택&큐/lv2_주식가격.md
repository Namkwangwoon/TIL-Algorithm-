# 주식가격
## 문제 설명
초 단위로 기록된 주식가격이 담긴 배열 prices가 매개변수로 주어질 때, 가격이 떨어지지 않은 기간은 몇 초인지를 return 하도록 solution 함수를 완성하세요.

## 제한사항
- prices의 각 가격은 1 이상 10,000 이하인 자연수입니다.
- prices의 길이는 2 이상 100,000 이하입니다.

## 입출력 예
|prices|return|
|-|-|
|[1, 2, 3, 2, 3]|[4, 3, 1, 1, 0]|

## 입출력 예 설명
- 1초 시점의 ₩1은 끝까지 가격이 떨어지지 않았습니다.
- 2초 시점의 ₩2은 끝까지 가격이 떨어지지 않았습니다.
- 3초 시점의 ₩3은 1초뒤에 가격이 떨어집니다. 따라서 1초간 가격이 떨어지지 않은 것으로 봅니다.
- 4초 시점의 ₩2은 1초간 가격이 떨어지지 않았습니다.
- 5초 시점의 ₩3은 0초간 가격이 떨어지지 않았습니다.

# 다른 사람의 풀이1
- 쉬운 문제라고 생각했지만, 이중 for문 외에 큐나 스택을 활용한 풀이법이 생각나지 않았다.
- stack을 사용해 풀려고 해봤지만, 생각이 안나서 결국 다른 사람의 풀이를 참고했다.
```python
def solution(prices):
    stack = [0]
    l = len(prices)
    answer = [l-i-1 for i in range(l)]
    
    for i, p in enumerate(prices[1:]):
        while stack and p<prices[stack[-1]]:
            j = stack.pop()
            answer[j] = i-j+1
        stack.append(i+1)
        
    return answer
```
정확성  테스트
```
테스트 1 〉	통과 (0.01ms, 10.1MB)
테스트 2 〉	통과 (0.06ms, 10.3MB)
테스트 3 〉	통과 (0.28ms, 10MB)
테스트 4 〉	통과 (0.35ms, 10.3MB)
테스트 5 〉	통과 (0.72ms, 10.2MB)
테스트 6 〉	통과 (0.02ms, 10.3MB)
테스트 7 〉	통과 (0.38ms, 10.3MB)
테스트 8 〉	통과 (0.42ms, 10MB)
테스트 9 〉	통과 (0.03ms, 10.3MB)
테스트 10 〉	통과 (0.40ms, 10.3MB)
```
효율성  테스트
```
테스트 1 〉	통과 (37.20ms, 19.9MB)
테스트 2 〉	통과 (24.26ms, 18MB)
테스트 3 〉	통과 (41.40ms, 20.1MB)
테스트 4 〉	통과 (28.09ms, 18.5MB)
테스트 5 〉	통과 (20.04ms, 17.4MB)
```
- 먼저 모든 가격이 떨어지지 않는 경우로 answer를 초기화
- stack을 활용한 풀이법으로써, stack에는 아직 자신의 가격보다 떨어진 가격을 만나지 못한 index들이 존재하도록 함
  - stack의 index의 가격들은 자신보다 떨어진 가격을 만나지 못한 것들이므로, 가격이 오름차순으로 들어가있다.
  - 따라서 price[stack[-1]]는 자신보다 떨어진 가격을 만나지 못한 가격들 중, 최대값
- price[stack[-1]]보다 낮은 가격을 만나면, stack의 index들을 꺼내보면서 비교를 시작해야함
  - 이 때, 자신보다 낮은 가격이라면, answer를 index로 접근하여 수정
  
# 다른 사람의 풀이2
- queue로도 풀 수 있다.
```python
from collections import deque

def solution(prices):
    q = deque(prices)
    answer = []
    
    while q:
        p = q.popleft()
        for i, q_p in enumerate(q):
            if p>q_p:
                answer.append(i+1)
                break
        else:
            answer.append(i+1)
            
    return answer[:-1]+[0]
```
정확성  테스트
```
테스트 1 〉	통과 (0.01ms, 10.3MB)
테스트 2 〉	통과 (0.04ms, 10.2MB)
테스트 3 〉	통과 (0.36ms, 10.3MB)
테스트 4 〉	통과 (0.78ms, 10.5MB)
테스트 5 〉	통과 (0.56ms, 10.2MB)
테스트 6 〉	통과 (0.02ms, 10.1MB)
테스트 7 〉	통과 (0.24ms, 10.2MB)
테스트 8 〉	통과 (0.27ms, 10.2MB)
테스트 9 〉	통과 (0.04ms, 10.2MB)
테스트 10 〉	통과 (0.50ms, 10.2MB)
```
효율성  테스트
```
테스트 1 〉	통과 (64.90ms, 18.7MB)
테스트 2 〉	통과 (55.35ms, 17.6MB)
테스트 3 〉	통과 (84.54ms, 19.8MB)
테스트 4 〉	통과 (57.86ms, 18.1MB)
테스트 5 〉	통과 (38.63ms, 17.3MB)
```
- 이중 for문 방법과 매우 유사한 방식
- prices를 큐로 만든 다음, 하나씩 꺼내 보면서 나머지 queue에서 자신보다 떨어진 가격을 찾음
- 큐를 사용했다는점 떄문에, 효율성 테스트를 통과한 듯 싶다.
