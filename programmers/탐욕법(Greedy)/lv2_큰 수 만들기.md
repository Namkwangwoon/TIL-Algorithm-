# 큰 수 만들기
## 문제 설명
어떤 숫자에서 k개의 수를 제거했을 때 얻을 수 있는 가장 큰 숫자를 구하려 합니다.

예를 들어, 숫자 1924에서 수 두 개를 제거하면 [19, 12, 14, 92, 94, 24] 를 만들 수 있습니다. 이 중 가장 큰 숫자는 94 입니다.

문자열 형식으로 숫자 number와 제거할 수의 개수 k가 solution 함수의 매개변수로 주어집니다. number에서 k 개의 수를 제거했을 때 만들 수 있는 수 중 가장 큰 숫자를 문자열 형태로 return 하도록 solution 함수를 완성하세요.

## 제한 조건
- number는 2자리 이상, 1,000,000자리 이하인 숫자입니다.
- k는 1 이상 `number의 자릿수` 미만인 자연수입니다.

## 입출력 예
|number|k|return|
|-|-|-|
|"1924"|2|"94"|
|"1231234"|3|"3234"|
|"4177252841"|4|"775841"|

# 내 풀이
```python
def solution(number, k):
    num_list = list(map(int, list(number)))
    i = 0
    
    while k>0:
        max_val = max(num_list[i:i+k+1])
        
        while k>0 and max_val>num_list[i]:
            num_list.pop(i)
            k-=1
            
        if i+k+1<len(num_list):
            i+=1
        else:
            for j in range(k):
                num_list.pop()
            break
    
    return "".join(map(str, num_list))
```
정확성  테스트
```
테스트 1 〉	통과 (0.04ms, 10.3MB)
테스트 2 〉	통과 (0.05ms, 10.4MB)
테스트 3 〉	통과 (0.06ms, 10.5MB)
테스트 4 〉	통과 (0.43ms, 10.4MB)
테스트 5 〉	통과 (0.49ms, 10.2MB)
테스트 6 〉	통과 (105.17ms, 10.8MB)
테스트 7 〉	통과 (298.53ms, 13MB)
테스트 8 〉	통과 (2666.95ms, 15MB)
테스트 9 〉	통과 (125.75ms, 34.1MB)
테스트 10 〉	실패 (시간 초과)
테스트 11 〉	통과 (0.03ms, 10.3MB)
테스트 12 〉	통과 (0.03ms, 10.5MB)
```
- 결과는 잘 나오는 것 같지만, 시간초과가 나온걸 보면, 시간 복잡도가 너무 높았던 것 같다.
- 결국 다른 사람의 풀이를 참고하여 코드를 다시 짰다.

# 다른 사람의 풀이1
```python
def solution(number, k):
    stack = [number[0]]
    
    for num in number[1:]:
        while k>0 and stack and stack[-1]<num:
            stack.pop()
            k-=1
        stack.append(num)
    
    return ''.join(stack[:len(stack)-k])
```
정확성  테스트
```
테스트 1 〉	통과 (0.01ms, 10.1MB)
테스트 2 〉	통과 (0.01ms, 10.2MB)
테스트 3 〉	통과 (0.05ms, 10.2MB)
테스트 4 〉	통과 (0.15ms, 10.2MB)
테스트 5 〉	통과 (0.16ms, 10.1MB)
테스트 6 〉	통과 (4.46ms, 10.3MB)
테스트 7 〉	통과 (6.38ms, 10.5MB)
테스트 8 〉	통과 (19.76ms, 10.9MB)
테스트 9 〉	통과 (27.42ms, 15.1MB)
테스트 10 〉	통과 (107.79ms, 14.3MB)
테스트 11 〉	통과 (0.01ms, 10.2MB)
테스트 12 〉	통과 (0.00ms, 10MB)
```
- stack으로 푼 풀이
- 원리
  - number의 수를 하나씩 스택에 넣되, 스택의 수는 내림차순이 되도록 해야함
  - 스택[-1] < num 이면 내림차순이 깨지므로, 스택[-1] >= num 일 때 까지 스택 pop()
    - pop()은 최대 k번 까지만 가능! => pop() 할 때 마다 k-=1
  - 스택에 다 넣었을 때에도, k번 pop()이 되지 않았다면 (k>0 이라면), stack의 끝 k개를 제외 => 스택[:-k]
- `내 풀이1`과 코드상 시간복잡도는 비슷해 보이지만, pop(i)가 시간을 많이 잡아먹은 것 같다
  - pop(i)를 pop()으로 바꾸면, 실패하지만 시간초과는 안뜬다.. pop(xx)를 되도록 쓰지 말아야겠군
